#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic
# state:  qQA1P8WKUGwkyDUiaYe3PAyi1oBoc1ZkkAt2mDQPve0
# istate: KLAtwC38rX1voAyfi/vG2ambKyzSDDaTNvVSlH0gIF0
# id:     UCdVwr+1QqTcieO7/hgq5d0RK7S9wX4N9biQ/ecDzZo

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is a hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};
meta::meta('configure', <<'__');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__
meta::meta('externalize', <<'__');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  my $escaped = $name;
  $escaped =~ s/[^A-Za-z0-9:]/_/go;
  $externalized_functions{$name} = $externalized_functions{$escaped} = $attribute;
  *{"::$name"} = *{"::$escaped"} = $implementation || $attribute;
}
__
meta::meta('externalize_template', <<'__');
sub meta::externalize_template {
  my ($name, $implementation) = @_;
  meta::externalize "template::$name", "template::$name", $implementation;
}
__
meta::meta('functor::code-templates', <<'__');
package code;

# Templates for generating named source files.
sub template {
  my ($name, $implementation) = @_;
  $implementation ||= sub {
    my ($line, $block) = @_;
    my $append         = $line =~ s/^\h*>>\h*//o;

    $line =~ s/\s+.*$//o;
    file::write($line, ($append && "\n") . $block, mkpath => 1, append => $append);
    "\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{${name}code}\n$block \\end{${name}code}";
  };

  meta::externalize_template $name, $implementation;
}
__
meta::meta('functor::editable', <<'__');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return &{$options{default}}(retrieve($attribute)) if ref $options{default} eq 'CODE' and not defined $command;
      return edit($attribute) if $command eq 'edit' or $options{default} eq 'edit' and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute)}}}
__
meta::meta('functor::tex-templates', <<'__');
package tex;

# A wrapper for TeX templates. The idea is always the same, so I'm abstracting out the
# common externalization logic here.
sub template_for(&) {
  my ($implementation) = @_;
  sub {
    my %names = @_;
    for my $name (keys %names) {
      ::meta::externalize_template $name, sub {
        &$implementation($names{$name}, @_);
      };
    }
  };
}

sub id {
  map {$_ => $_} @_;
}

# Creates a one-line or multiline template based on normal TeX syntax. It's a straight
# transfer into TeX with no preprocessing.
*template = template_for {
  my ($name, $line, $block) = @_;
  $block ? "\\begin{$name}\n$block\n\\end{$name}" : "\\$name\{$line\}";
};

# Creates a labeled one-line template. This is just like normal TeX, but assumes the
# specification of a label name after a pipe character.
*labeled_template = template_for {
  my ($name, $line, undef) = @_;
  my ($real_stuff, $label) = split /\h*\|\h*/, $line, 2;
  "\\$name\{$real_stuff\}" . template::label($label);
};
__
meta::meta('template::beamer', <<'__');
tex::template tex::id(qw/frame pause block alertblock exampleblock/);

my $fframe_template = tex::template_for {
  my ($name, $line, $block) = @_;
  "\\begin{frame}[fragile]\n$block\n\\end{frame}\n";
};
&$fframe_template(tex::id('fframe'));
__
meta::meta('template::code', 'code::template $_ for qw/java cpp asm javascript html resource perl ruby python/;');
meta::meta('template::document', 'tex::template tex::id(qw/document tableofcontents maketitle title author date abstract documentclass verbatim/);');
meta::meta('template::enumeration', <<'__');
tex::template tex::id(qw/enumerate itemize description/);
tex::labeled_template tex::id(qw/item/);
__
meta::meta('template::math', <<'__');
tex::template align => 'align*', nalign => 'align';
tex::template tex::id(qw/theorem proof lemma corollary conjecture definition proposition/);
__
meta::meta('template::quotations', 'tex::template tex::id(qw/quotation quote/);');
meta::meta('template::sections', <<'__');
tex::labeled_template(s1 => 'section', s2 => 'subsection', s3 => 'subsubsection', s4 => 'paragraph', s5 => 'subparagraph');
tex::labeled_template(sc => 'chapter', sp => 'part');
__
meta::meta('type::alias', <<'__');
meta::configure 'alias', inherit => 0, trim => 1;
meta::define_form 'alias', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "alias::$name", sub {
    # Can't pre-tokenize because shell::tokenize doesn't exist until the library::
    # namespace has been evaluated (which will be after alias::).
    shell::run(shell::tokenize($value), shell::tokenize(@_));
  };
};
__
meta::meta('type::bootstrap', <<'__');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'bootstrap', sub {};
__
meta::meta('type::cache', <<'__');
meta::configure 'cache', inherit => 0, trim => 1;
meta::define_form 'cache', \&meta::bootstrap::implementation;
__
meta::meta('type::data', 'meta::functor::editable \'data\', extension => \'\', inherit => 0, default => \'cat\';');
meta::meta('type::function', <<'__');
meta::configure 'function', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__
meta::meta('type::hook', <<'__');
meta::configure 'hook', extension => '.pl', inherit => 0, trim => 1;
meta::define_form 'hook', sub {
  my ($name, $value) = @_;
  *{"hook::$name"} = meta::eval_in("sub {\n$value\n}", "hook::$name");
};
__
meta::meta('type::inc', <<'__');
meta::configure 'inc', inherit => 1, extension => '.pl', trim => 1;
meta::define_form 'inc', sub {
  use File::Path 'mkpath';
  use File::Basename qw/basename dirname/;

  my ($name, $value) = @_;
  my $tmpdir   = basename($0) . '-' . $$;
  my $filename = "/tmp/$tmpdir/$name";

  push @INC, "/tmp/$tmpdir" unless grep /^\/tmp\/$tmpdir$/, @INC;

  mkpath(dirname($filename));
  unless (-e $filename) {
    open my $fh, '>', $filename;
    print $fh $value;
    close $fh;
  }
};
__
meta::meta('type::indicator', <<'__');
# Shell indicator function. The output of each of these is automatically
# appended to the shell prompt.

meta::configure 'indicator', inherit => 1, extension => '.pl', trim => 1;
meta::define_form 'indicator', sub {
  my ($name, $value) = @_;
  *{"indicator::$name"} = meta::eval_in("sub {\n$value\n}", "indicator::$name");
};
__
meta::meta('type::internal_function', <<'__');
meta::configure 'internal_function', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__
meta::meta('type::library', <<'__');
meta::configure 'library', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
};
__
meta::meta('type::message_color', <<'__');
meta::configure 'message_color', extension => '', inherit => 1, trim => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__
meta::meta('type::meta', <<'__');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1, trim => 1;
__
meta::meta('type::parent', <<'__');
meta::define_form 'parent', \&meta::bootstrap::implementation;
meta::configure 'parent', extension => '', inherit => 1, trim => 1;
__
meta::meta('type::psection', <<'__');
# Perl TeX section (separated out to help vim syntax highlighter)
meta::functor::editable 'psection', extension => '.perltex', inherit => 0,
                                    default => 'edit';
__
meta::meta('type::resource', 'meta::functor::editable \'resource\', extension => \'.cltex\', inherit => 1, default => \'edit\';');
meta::meta('type::retriever', <<'__');
meta::configure 'retriever', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'retriever', sub {
  my ($name, $value) = @_;
  $transient{retrievers}{$name} = meta::eval_in("sub {\n$value\n}", "retriever::$name");
};
__
meta::meta('type::sdoc', <<'__');
# A meta-type for other types. So retrieve('js::main') will work if you have
# the attribute 'sdoc::js::main'. The filename will be main.js.sdoc.

meta::functor::editable 'sdoc', inherit => 1, extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};
__
meta::meta('type::section', 'meta::functor::editable \'section\', extension => \'.cltex\', inherit => 0, default => \'edit\';');
meta::meta('type::slibrary', <<'__');
meta::configure 'slibrary', extension => '.pl.sdoc', inherit => 1;
meta::define_form 'slibrary', sub {
  my ($name, $value) = @_;
  meta::eval_in(sdoc("slibrary::$name"), "slibrary::$name");
};
__
meta::meta('type::state', <<'__');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl', trim => 1;
meta::define_form 'state', \&meta::bootstrap::implementation;
__
meta::meta('type::template', <<'__');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__
meta::meta('type::vim_highlighter', <<'__');
meta::configure 'vim_highlighter', extension => '.vim', inherit => 1;
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__
meta::alias('eM', 'edit section::main');
meta::alias('eb', 'edit section::business-protocol');
meta::alias('ec', 'edit section::coding-interview');
meta::alias('ei', 'edit section::the-interviewer');
meta::alias('em', 'edit section::meeting-in-person');
meta::alias('er', 'edit section::resume');
meta::alias('eti', 'edit section::the-interviewer');
meta::alias('etp', 'edit section::technical-phone-interview');
meta::bootstrap('html', <<'__');
<html>
  <head>
  <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
  <link rel='stylesheet' href='http://spencertipping.com/perl-objects/web/style.css'/>

  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js'></script>
  <script src='http://spencertipping.com/caterwaul/caterwaul.all.min.js'></script>
  <script src='http://spencertipping.com/montenegro/montenegro.client.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/attribute-parser.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/interface.js'></script>
  </head>
  <body></body>
</html>
__
meta::bootstrap('initialization', <<'__');
#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic
# state:  __state
# istate: __istate
# id:     __id

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is a hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};
__
meta::bootstrap('perldoc', <<'__');
=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/writing-self-modifying-perl>. For quick usage guidelines,
run this script with the 'usage' argument.

=cut
__
meta::cache('parent-identification', <<'__');
/home/spencertipping/r/initiative/perl-objects/tex-document d6b8b54aecc42ae92c7a8c570c5559fc
object 99aeabc9ec7fe80b1b39f5e53dc7e49e
preprocessor 70dae4b46eb4e06798ec6f38d17d4c7b
sdoc a1e8480e579614c01dabeecf0f963bcc
vim-highlighters 902333a0bd6ed90ff919fe8477cb4e69
__
meta::cache('parent-state', <<'__');
70dae4b46eb4e06798ec6f38d17d4c7b aVkS5uQvv85hgzS3VDzMTfOKCXBPxJ8n+FHe2wroaCc
902333a0bd6ed90ff919fe8477cb4e69 a2UfhjT/gGzuzJhjQpPzYghjO5CQH4FkK/o/GudHAo8
99aeabc9ec7fe80b1b39f5e53dc7e49e holS25TrO+3fs32MO59ho89mpKn8EBmiLLfcl/XpCSU
a1e8480e579614c01dabeecf0f963bcc TBP4VqMuHSrBGYCiWy55lQf/m9n+oFaFNxsHIxBGCnQ
d6b8b54aecc42ae92c7a8c570c5559fc r/XuS0NmAOK5ctQCiJapfDA6ij7HcGK1LDWOA1k6ttI
__
meta::data('author', 'Spencer Tipping');
meta::data('default-action', 'shell');
meta::data('license', <<'__');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__
meta::data('permanent-identity', 'UCdVwr+1QqTcieO7/hgq5d0RK7S9wX4N9biQ/ecDzZo');
meta::function('ad', <<'__');
my ($options, @paths) = separate_options(@_);
@{$transient{path}} = () if $$options{-c};
return @{$transient{path}} = () unless @paths;
push @{$transient{path}}, @paths;
__
meta::function('alias', <<'__');
my ($name, @stuff) = @_;
@_ ? @stuff ? around_hook('alias', @_, sub {associate("alias::$name", join(' ', @stuff), execute => 1)})
            : retrieve("alias::$name") // "Undefined alias $name"
   : table_display([select_keys('--namespace' => 'alias')], [map retrieve($_), select_keys('--namespace' => 'alias')]);
__
meta::function('cat', 'join "\\n", retrieve(@_);');
meta::function('cc', <<'__');
# Stashes a quick one-line continuation. (Used to remind me what I was doing.)
@_ ? associate('data::current-continuation', hook('set-cc', join(' ', @_))) : retrieve('data::current-continuation');
__
meta::function('ccc', 'rm(\'data::current-continuation\');');
meta::function('cd', <<'__');
my ($options, @stuff) = separate_options(@_);
my @new_stuff = map "${_}::", @stuff;
ad(%$options, @new_stuff);
__
meta::function('child', <<'__');
around_hook('child', @_, sub {
  my ($child_name) = @_;
  clone($child_name);
  enable();
  qx($child_name update-from $0);
  terminal::info("$child_name\'s identity is " . join '', qx($child_name identity));
  disable()});
__
meta::function('clone', <<'__');
my ($options, @files) = separate_options(@_);
for my $file (@files) {
  around_hook('clone', $file, sub {
    hypothetically(sub {
      # Assign a new object identity.
      rm('data::permanent-identity');
      identity();

      file::write($file, serialize(), noclobber => 1);
      chmod(0700, $file)})})}
__
meta::function('compile-tex', <<'__');
my ($options, @documents) = separate_options(@_);
my $temporary_directory = temporary_name();

my $tex = tex(@documents);
my $toc = $tex =~ /\\tableofcontents/;

mkdir $temporary_directory;
file::write(my $filename = "$temporary_directory/document.tex", tex(@documents));

my $destination = $$options{'--pdf'} || name() . '.pdf';
my $output = $filename;
$output =~ s/\.tex$/.pdf/;

my $opts = "-output-directory=$temporary_directory";

$toc ? sh("latex $opts $filename && latex $opts $filename && pdflatex $opts $filename && mv $output $destination && rm -r $temporary_directory")
     : sh("pdflatex $opts $filename && mv $output $destination && rm -r $temporary_directory");
__
meta::function('cp', <<'__');
my $from = shift @_;
my $value = retrieve($from);
associate($_, $value) for @_;
__
meta::function('create', <<'__');
my ($name, $value) = @_;
around_hook('create', $name, $value, sub {
  return edit($name) if exists $data{$name};
  associate($name, defined $value ? $value : '');
  edit($name) unless defined $value});
__
meta::function('current-state', 'serialize(\'-pS\');');
meta::function('cwd', <<'__');
use Cwd qw/getcwd/;
getcwd();
__
meta::function('disable', 'hook(\'disable\', chmod_self(sub {$_[0] & 0666}));');
meta::function('edit', <<'__');
my ($options, @names) = separate_options(@_);
@names = select_keys('--criteria' => "^$$options{'--prefix'}.*" . join('.*', @names), %$options) if $$options{'--prefix'};

my ($name, @others) = @names;
die "cannot edit multiple attributes simultaneously (others are @others)" if @others;
die "$name is virtual or does not exist" unless exists $data{$name};
die "$name is inherited; use 'edit $name -f' to edit anyway" unless is($name, '-u') || is($name, '-d') || exists $$options{'-f'};

my $extension = extension_for($name);
my $changed   = 0;
around_hook('edit', @_, sub {
  my $result = invoke_editor_on($data{$name} // '', %$options, attribute => $name, extension => $extension);
  $changed += $data{$name} ne $result;
  associate($name, $result, execute => 1)});

save() unless !$changed or $data{'data::edit::no-save'} or state() eq $transient{initial};
$changed;
__
meta::function('edit-self', <<'__');
$global_data = invoke_editor_on($global_data);
save();
__
meta::function('enable', 'hook(\'enable\', chmod_self(sub {$_[0] | ($_[0] & 0444) >> 2}));');
meta::function('expanded-bootstrap', <<'__');
# Write headers into the bootstrap section. There is some subtle stuff going on
# here with the istate header. The idea is to provide other objects a very quick
# way to see whether our state has changed, but we don't want false positives.
# We would get a false positive if, for instance, we included the contents of
# parent:: attributes in the istate hash. The reason is that the parent::
# attribute contains a hash of every attribute provided by that parent, so any
# change in the parent would impact the istate of the child.
#
# The best way to deal with this is to treat parent:: attributes as being
# opaque; we record their existence or nonexistence, but we don't record their
# contents. We also look only at inheritable and unique attributes and fail to
# consider global state.

my $bootstrap_text = retrieve('bootstrap::initialization');
my $state          = state();
my $istate         = state('-iGP');
my $object_id      = identity();

$bootstrap_text =~ s/__state/$state/g;
$bootstrap_text =~ s/__istate/$istate/g;
$bootstrap_text =~ s/__id/$object_id/g;

$bootstrap_text;
__
meta::function('export', <<'__');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt
my $name = pop @_;
@_ or die 'Expected filename';
file::write($name, join "\n", retrieve(@_));
__
meta::function('extern', '&{$_[0]}(retrieve(@_[1 .. $#_]));');
meta::function('grep', <<'__');
# Looks through attributes for a pattern. Usage is grep pattern [options], where
# [options] is the format as provided to select_keys.

my ($pattern, @args)     = @_;
my ($options, @criteria) = separate_options(@args);
my @attributes           = select_keys(%$options, '--criteria' => join('|', @criteria));

$pattern = qr/$pattern/;

my @m_attributes;
my @m_line_numbers;
my @m_lines;

for my $k (@attributes) {
  next unless length $k;
  my @lines = split /\n/, retrieve($k);
  for (0 .. $#lines) {
    next unless $lines[$_] =~ $pattern;
    push @m_attributes,   $k;
    push @m_line_numbers, $_ + 1;
    push @m_lines,        '' . ($lines[$_] // '')}}

unless ($$options{'-C'}) {
  s/($pattern)/\033[1;31m\1\033[0;0m/g for @m_lines;
  s/^/\033[1;34m/o for @m_attributes;
  s/^/\033[1;32m/o && s/$/\033[0;0m/o for @m_line_numbers}

table_display([@m_attributes], [@m_line_numbers], [@m_lines]);
__
meta::function('hash', 'fast_hash(@_);');
meta::function('hook', <<'__');
my ($hook, @args) = @_;
$transient{active_hooks}{$hook} = 1;
dangerous('', sub {&$_(@args)}) for grep /^hook::${hook}::/, sort keys %data;
@args;
__
meta::function('hooks', 'join "\\n", sort keys %{$transient{active_hooks}};');
meta::function('identity', <<'__');
retrieve('data::permanent-identity') or
associate('data::permanent-identity', fast_hash(join '|', map rand(), 1 .. 32));
__
meta::function('import', <<'__');
my $name = pop @_;
associate($name, @_ ? join('', map(file::read($_), @_)) : join('', <STDIN>));
__
meta::function('initial-state', '$transient{initial};');
meta::function('is', <<'__');
my ($attribute, @criteria) = @_;
my ($options, @stuff) = separate_options(@criteria);
exists $data{$attribute} and attribute_is($attribute, %$options);
__
meta::function('load-state', <<'__');
around_hook('load-state', @_, sub {
  my ($state_name) = @_;
  my $state = retrieve("state::$state_name");

  terminal::state('saving current state into _...');
  save_state('_');

  delete $data{$_} for grep ! /^state::/, keys %data;
  %externalized_functions = ();

  terminal::state("restoring state $state_name...");
  meta::eval_in($state, "state::$state_name");
  terminal::error(hook('load-state-failed', $@)) if $@;
  reload();
  verify()});
__
meta::function('lock', 'hook(\'lock\', chmod_self(sub {$_[0] & 0555}));');
meta::function('ls', <<'__');
my ($options, @criteria) = separate_options(@_);
my ($external, $shadows, $sizes, $flags, $long, $hashes, $parent_hashes) = @$options{qw(-e -s -z -f -l -h -p)};
$sizes = $flags = $hashes = $parent_hashes = 1 if $long;

return table_display([grep ! exists $data{$externalized_functions{$_}}, sort keys %externalized_functions]) if $shadows;

my $criteria    = join('|', @criteria);
my @definitions = select_keys('--criteria' => $criteria, '--path' => $transient{path}, %$options);

my %inverses  = map {$externalized_functions{$_} => $_} keys %externalized_functions;
my @externals = map $inverses{$_}, grep length, @definitions;
my @internals = grep length $inverses{$_}, @definitions;
my @sizes     = map sprintf('%6d %6d', length(serialize_single($_)), length(retrieve($_))), @{$external ? \@internals : \@definitions} if $sizes;

my @flags     = map {my $k = $_; join '', map(is($k, "-$_") ? $_ : '-', qw(d i m u))} @definitions if $flags;
my @hashes    = map fast_hash(retrieve($_)), @definitions if $hashes;

my %inherited     = parent_attributes(grep /^parent::/o, keys %data) if $parent_hashes;
my @parent_hashes = map $inherited{$_} || '-', @definitions if $parent_hashes;

join "\n", map strip($_), split /\n/, table_display($external ? [grep length, @externals] : [@definitions],
                                                    $sizes ? ([@sizes]) : (), $flags ? ([@flags]) : (), $hashes ? ([@hashes]) : (), $parent_hashes ? ([@parent_hashes]) : ());
__
meta::function('make', 'compile_tex("--pdf=" . name() . ".pdf");');
meta::function('mv', <<'__');
my ($from, $to) = @_;
die "'$from' does not exist" unless exists $data{$from};
associate($to, retrieve($from), execute => 1);
rm($from);
__
meta::function('name', <<'__');
my $name = $0;
$name =~ s/^.*\///;
$name;
__
meta::function('parents', 'join "\\n", grep s/^parent:://o, sort keys %data;');
meta::function('perl', <<'__');
my @result = eval(join ' ', @_);
$@ ? terminal::error($@) : wantarray ? @result : $result[0];
__
meta::function('preprocess', <<'__');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__
meta::function('rd', <<'__');
if (@_) {my $pattern = join '|', @_;
         @{$transient{path}} = grep $_ !~ /^$pattern$/, @{$transient{path}}}
else    {pop @{$transient{path}}}
__
meta::function('reload', 'around_hook(\'reload\', sub {execute($_) for grep ! /^bootstrap::/, keys %data});');
meta::function('rm', <<'__');
around_hook('rm', @_, sub {
  exists $data{$_} or terminal::warning("$_ does not exist") for @_;
  delete @data{@_}});
__
meta::function('rmparent', <<'__');
# Removes one or more parents.
my ($options, @parents) = separate_options(@_);
my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

my %parents = map {$_ => 1} @parents;
my @other_parents = grep !$parents{$_}, grep s/^parent:://, select_keys('--namespace' => 'parent');
my %kept_by_another_parent;

$kept_by_another_parent{$_} = 1 for grep s/^(\S+)\s.*$/\1/, split /\n/o, cat(@other_parents);

for my $parent (@parents) {
  my $keep_parent_around = 0;

  for my $line (split /\n/, retrieve("parent::$parent")) {
    my ($name, $hash) = split /\s+/, $line;
    next unless exists $data{$name};

    my $local_hash = fast_hash(retrieve($name));
    if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name) unless $kept_by_another_parent{$name}}
    else {terminal::info("local attribute $name exists and is divergent; use rmparent -D $parent to delete it");
          $keep_parent_around = 1}}

  $keep_parent_around ? terminal::info("not deleting parent::$parent so that you can run", "rmparent -D $parent if you want to nuke divergent attributes too")
                      : rm("parent::$parent")}
__
meta::function('save', 'around_hook(\'save\', sub {dangerous(\'\', sub {file::write($0, serialize(\'-V\')); $transient{initial} = state()}) if verify()});');
meta::function('save-state', <<'__');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
around_hook('save-state', $state_name, sub {
  associate("state::$state_name", current_state(), execute => 1)});
__
meta::function('sdoc', <<'__');
# Applies SDoc processing to a file or attribute. Takes the file or attribute
# name as the first argument and returns the processed text.

my %comments_for_extension = 
  qw|c     /*,*/  cpp   //    cc   //    h    /*,*/ java //  py  #    rb   #    pl  #   pm   #         ml   (*,*)  js  //
     hs    --     sh    #     lisp ;;;   lsp  ;;;   s    #   scm ;;;  sc   ;;;  as  //  html <!--,-->  mli  (*,*)  cs  //
     vim   "      elisp ;     bas  '     ada  --    asm  ;   awk #    bc   #    boo #   tex  %         fss  (*,*)  erl %
     scala //     hx    //    io   //    j    NB.   lua  --  n   //   m    %    php //  sql  --        pov  //     pro %
     r     #      self  ","   tcl  #     texi @c    tk   #   csh #    vala //   vbs '   v    /*,*/     vhdl --     ss  ;;;
     haml  -#     sass  /*,*/ scss /*,*/ css  /*,*/ fig  /   waul #   hh   //   ps  %   canard nb[,]   x    /*,*/  xr  /*,*/
     xu    /*,*/  xn    /*,*/ xbn  /*,*/ xs   /*,*/ m4   dnl|;

# No extension suggests a shebang line, which generally requires # to denote a comment.
$comments_for_extension{''} = '#';

my $generated_string = 'Generated by SDoc';

sub is_code    {map /^\s*[^A-Z\|\s]/o, @_}
sub is_blank   {map /^\n/o, @_}
sub comment    {my ($text, $s, $e) = @_; join "\n", map("$s $_" . (length $e ? " $e" : ''), split /\n/, $text)}

sub paragraphs {map split(/(\n(?:\h*\n)+)/, $_), @_}

my ($filename, $specified_extension) = @_;
my $logical_filename = $filename =~ /^sdoc::(.*)$/ ? $1 : $filename;

# Two possibilities here. One is that the filename is an attribute, in which case
# we want to look up the extension in the transients table. The other is that
# it's a real filename.
my $extension = $specified_extension || extension_for($logical_filename) || ($filename =~ /\.sdoc$/io ? $filename =~ /\.(\w+)\.sdoc$/igo : $filename =~ /\.(\w+)$/igo)[0];
$extension =~ s/^\.//o;

my ($start, $end) = split /,/o, $comments_for_extension{lc $extension} // $comments_for_extension{''} // '#';

join '', map(is_code($_) || is_blank($_) ? ($_ =~ /^\s*c\n(.*)$/so ? $1 : $_) : comment($_, $start, $end), paragraphs retrieve($filename)),
         "\n" . comment($generated_string, $start, $end) . "\n";
__
meta::function('sdoc-html', <<'__');
# Converts SDoc to logically-structured HTML. Sections end up being nested,
# and code sections and examples are marked as such. For instance, here is some
# sample output:

# <div class='section level1'>
#   <h1 class='title'>Foo</h1>
#   <p>This is a paragraph...</p>
#   <p>This is another paragraph...</p>
#   <pre class='code'>int main () {return 0;}</pre>
#   <pre class='quoted'>int main () {return 0} // Won't compile</pre>
#   <div class='section level2'>
#     <h2 class='title'>Bar</h2>
#     ...
#   </div>
# </div>

# It is generally good about escaping things that would interfere with HTML,
# but within text paragraphs it lets you write literal HTML. The heuristic is
# that known tags that are reasonably well-formed are allowed, but unknown ones
# are escaped.

my ($attribute)   = @_;
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $known_tags    = join '|', qw[html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption
                                 table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video strong em];
my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - 1); s/^$spaces//gm};

my $escape_all    = sub {s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g};
my $escape_some   = sub {s/&/&amp;/g; s/<(?!\/|($known_tags)[^>]*>.*<\/\1>)/&lt;/gs};

my $code          = sub {&$escape_all(); &$unindent(); s/^c\n//;                   push @markup, &$indent() . "<pre class='code'>$_</pre>"};
my $quoted        = sub {&$escape_all(); &$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, &$indent() . "<pre class='quoted'>$_</pre>"};

my $paragraph     = sub {&$escape_some(); push @markup, &$indent() . "<p>$_</p>"};

my $section       = sub {my $h = $_[0] > 6 ? 6 : $_[0]; push @markup, &$indent($_[0] - 1) . "<div class='section level$_[0]'>", &$indent($_[0]) . "<h$h>$2</h$h>"};
my $close_section = sub {push @markup, &$indent($_[0]) . "</div>"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1;
  &$close_section($section_level) while $section_level-- >= $indentation;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  &$paragraph();
}

&$close_section($section_level) while $section_level--;

join "\n", @markup;
__
meta::function('sdoc-markdown', <<'__');
# Renders a chunk of SDoc as Markdown. This involves converting quoted and
# unquoted code and section headings, but not numbered lists.

my ($attribute, %options) = @_;
my ($adjust, $quote_code) = @options{qw/adjust quote_code/};
$adjust //= 0;

my $extension     = extension_for($attribute =~ /^sdoc::(.*)$/g) || ($attribute =~ /.*?\.([^\.]+)(?:\.sdoc)?$/gi)[0];
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - $adjust - 1); s/^$spaces//gm; $_};

my $code          = sub {goto &$quoted if $quote_code;
                         &$unindent(); s/^c\n//;                   push @markup, "```$extension\n$_\n```"};
my $quoted        = sub {&$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, join("\n", map &$indent(2) . $_, split /\n/)};

my $heading       = sub {'#' x $_[0]};
my $section       = sub {&$unindent(); push @markup, &$heading($_[0]) . ' ' . $2};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1 + $adjust;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  push @markup, join "\n", map &$unindent(), split /\n/;
}

join "\n\n", @markup;
__
meta::function('sdoc-packed', <<'__');
# An SDoc preprocessor that removes all comment paragraphs. Paragraph breaks
# are preserved, and no "generated by SDoc" string is added.
join "\n", grep /^\s*[^A-Z| ]/, split /\n(?:\s*\n)+/, retrieve(@_);
__
meta::function('sdoc-pod', <<'__');
# Renders a chunk of SDoc as POD. This involves converting quoted and
# unquoted code and section headings, but not numbered lists. It also
# involves converting Markdown's code-text and link syntax.

use List::Util qw/min/;

my ($attribute, %options) = @_;
my ($adjust, $quote_code) = @options{qw/adjust quote_code/};
$adjust //= 0;

my $extension     = extension_for($attribute =~ /^sdoc::(.*)$/g) || ($attribute =~ /.*?\.([^\.]+)(?:\.sdoc)?$/gi)[0];
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - $adjust - 1); s/^$spaces//gm; $_};

my $code          = sub {goto &$quoted if $quote_code;
                         &$unindent(); s/^c\n//;                   push @markup, "=cut\n\n$_\n\n=pod"};
my $quoted        = sub {&$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, join "\n", map "  $_", split /\n/};
my $section       = sub {&$unindent(); push @markup, "=head$_[0] $2"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1 + $adjust;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  # Anything below here is a "normal" (i.e. commented) paragraph, so
  # normal text-transformation rules apply.
  s/`([^`]+?)`/C<<<<< $1 >>>>>/g;       # Markdown inline code
  s/\[([^]]+)\]\(([^)]+)\)/L<$1|$2>/g;  # Markdown link

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);

  # Undo any consistent indentation within a paragraph.
  {
    my $paragraph         = $_;
    my $indentation_level = min(map length(s/^(\s*).*/$1/rmg), split /\n/);
    my $spaces            = ' ' x $indentation_level;
    $_ = $paragraph =~ s/^$spaces//mgr;
  }

  push @markup, join "\n", map &$unindent(), split /\n/;
}

join "\n\n", @markup;
__
meta::function('sdocp', <<'__');
# Renders an attribute as SDocP. This logic was taken directly from the sdoc script.
my $attribute = retrieve($_[0]);
sub escape {my @results = map {s/\\/\\\\/go; s/\n/\\n/go; s/'/\\'/go; $_} @_; wantarray ? @results : $results[0]}
"sdocp('" . escape($_[0]) . "', '" . escape($attribute) . "');";
__
meta::function('serialize', <<'__');
my ($options, @criteria) = separate_options(@_);
delete $$options{'-P'};

my $partial     = delete $$options{'-p'};
my $criteria    = join '|', @criteria;
my @attributes  = map serialize_single($_), select_keys(%$options, '-m' => 1, '--criteria' => $criteria), select_keys(%$options, '-M' => 1, '--criteria' => $criteria);
my @final_array = @{$partial ? \@attributes : [expanded_bootstrap(), @attributes, 'internal::main();', '', '__DATA__', $global_data]};
join "\n", @final_array;
__
meta::function('serialize-single', <<'__');
# Serializes a single attribute and optimizes for content.

my $name          = $_[0] || $_;
my $contents      = retrieve_trimmed($name);
my $meta_function = 'meta::' . namespace($name);
my $invocation    = attribute($name);

if ($contents !~ /\v/) {
  $contents =~ s/\\/\\\\/go;
  $contents =~ s/'/\\'/go;
  return "$meta_function('$invocation', '$contents');"}

my $delimiter = '__' . fast_hash($contents);
my $chars     = 2;

++$chars until $chars >= length($delimiter) || index("\n$contents", "\n" . substr($delimiter, 0, $chars)) == -1;
$delimiter = substr($delimiter, 0, $chars);

"$meta_function('$invocation', <<'$delimiter');\n$contents\n$delimiter";
__
meta::function('sh', <<'__');
around_hook('sh', @_, sub {
  system(@_)});
__
meta::function('shb', <<'__');
# Backgrounded shell.
with_fork(@_, \&::sh);
__
meta::function('shell', <<'__');
my ($options, @arguments) = separate_options(@_);
$transient{repl_prefix} = $$options{'--repl-prefix'};

terminal::cc(retrieve('data::current-continuation')) if length $data{'data::current-continuation'};
around_hook('shell', sub {shell::repl(%$options)});
__
meta::function('size', <<'__');
my $size = 0;
$size += length $data{$_} for keys %data;
sprintf "   full logical  unique    self\n% 7d % 7d % 7d % 7d", length(serialize()), $size, length(serialize('-up')), length $global_data;
__
meta::function('snapshot', <<'__');
my ($name) = @_;
file::write(my $finalname = temporary_name($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
hook('snapshot', $finalname);
__
meta::function('snapshot-if-necessary', 'snapshot() if state() ne $transient{initial};');
meta::function('state', <<'__');
my ($options, @attributes) = separate_options(@_);
@attributes = grep !is($_, '-v'), sort keys %data unless @attributes;
@attributes = grep is($_, '-iu'), @attributes if $$options{'-i'};
@attributes = grep is($_, '-P'),  @attributes if $$options{'-P'};

my $hash = fast_hash(fast_hash(scalar @attributes) . join '|', @attributes);
$hash = fast_hash(retrieve_trimmed($_) . "|$hash") for @attributes;

$hash = fast_hash(join '|', $hash, grep s/^parent:://, sort keys %data)
if $$options{'-P'};

$$options{'-G'} ? $hash : fast_hash("$global_data|$hash");
__
meta::function('tex', <<'__');
my @documents = @_ ? @_ : qw/main/;
join "\n\n", map preprocess(retrieve("section::$_")), @documents;
__
meta::function('touch', 'associate($_, \'\') for @_;');
meta::function('u', <<'__');
my ($options, $count) = separate_options(@_);
$count //= 1;
rd() while $count--;
__
meta::function('unlock', 'hook(\'unlock\', chmod_self(sub {$_[0] | 0200}));');
meta::function('update', 'update_from(@_, grep s/^parent:://o, sort keys %data);');
meta::function('update-from', <<'__');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transient{inherit}{$type}.

# Note that this assumes you trust the remote script. If you don't, then you shouldn't update from it.

around_hook('update-from-invocation', separate_options(@_), sub {
  my ($options, @targets) = @_;
  my %parent_id_cache    = cache('parent-identification');
  my %parent_state_cache = cache('parent-state');
  my %already_seen;

  @targets or return;

  my @known_targets     = grep s/^parent:://, parent_ordering(map "parent::$_", grep exists $data{"parent::$_"}, @targets);
  my @unknown_targets   = grep ! exists $data{"parent::$_"}, @targets;
  @targets = (@known_targets, @unknown_targets);

  my $save_state        = $$options{'-s'} || $$options{'--save'};
  my $no_state          = $$options{'-S'} || $$options{'--no-state'};
  my $no_verify         = $$options{'-V'} || $$options{'--no-verify'};
  my $no_parents        = $$options{'-P'} || $$options{'--no-parent'} || $$options{'--no-parents'};
  my $force             = $$options{'-f'} || $$options{'--force'};
  my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

  my $can_skip_already_seen = !($$options{'-K'} || $$options{'--no-skip'}) &&
                              !$force && !$clobber_divergent;

  save_state('before-update') unless $no_state;

  for my $target (@targets) {
    dangerous("updating from $target", sub {
    around_hook('update-from', $target, sub {
      my $target_filename = strip(qx(which $target)) || $target;
      my %parent_metadata = %{metadata_from($target_filename)};
      terminal::warning("$target_filename has no externally visible metadata (makes updating slower)") unless $parent_metadata{id};

      my $identity = $parent_id_cache{$target} ||= $parent_metadata{id} || join '', qx($target identity);
      next if $can_skip_already_seen and
              exists $data{"parent::$target"} and
              $already_seen{$identity} || $parent_state_cache{$identity} eq $parent_metadata{istate};

      my $attributes = join '', qx($target ls -ahiu);
      my %divergent;
      die "skipping unreachable $target" unless $attributes;

      # These need to come after the reachability check so that we retry against
      # other copies in case something fails.
      ++$already_seen{$identity};
      $parent_state_cache{$identity} = $parent_metadata{istate} || join '', qx($target state -iPG);

      for my $to_rm (split /\n/, retrieve("parent::$target")) {
        my ($name, $hash) = split(/\s+/, $to_rm);
        next unless exists $data{$name};

        my $local_hash = fast_hash(retrieve($name));
        if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name)}
        else {terminal::info("preserving local version of divergent attribute $name (use update -D to clobber it)");
              $divergent{$name} = retrieve($name)}}

      associate("parent::$target", $attributes) unless $no_parents;

      dangerous('', sub {eval qx($target serialize -ipmu)});
      dangerous('', sub {eval qx($target serialize -ipMu)});

      map associate($_, $divergent{$_}), keys %divergent unless $clobber_divergent;

      reload()})})}

  cache('parent-identification', %parent_id_cache);
  cache('parent-state',          %parent_state_cache);

  if ($no_verify) {hook('update-from-presumably-succeeded', $options, @targets);
                   rm('state::before-update') unless $no_state || $save_state}
  elsif (verify()) {hook('update-from-succeeded', $options, @targets);
                    terminal::info("Successfully updated. Run 'load-state before-update' to undo this change.") if $save_state;
                    rm('state::before-update') unless $no_state || $save_state}
  elsif ($force || $no_state) {hook('update-from-failed', $options, @targets);
                               terminal::warning('Failed to verify: at this point your object will not save properly, though backup copies will be created.',
                                                 $no_state ? 'You should attempt to repair this object since no prior state was saved.'
                                                           : 'Run "load-state before-update" to undo the update and return to a working state.')}
  else {hook('update-from-failed', $options, @targets);
        terminal::error('Verification failed after the upgrade was complete.');
        terminal::info("$0 has been reverted to its pre-upgrade state.", "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
        load_state('before-update');
        rm('state::before-update')}});
__
meta::function('usage', '"Usage: $0 action [arguments]\\nUnique actions (run \'$0 ls\' to see all actions):" . ls(\'-u\');');
meta::function('verify', <<'__');
file::write(my $other = $transient{temporary_filename} = temporary_name(), my $serialized_data = serialize());
chomp(my $observed = join '', qx|perl '$other' state|);

unlink $other if my $result = $observed eq (my $state = state());
terminal::error("Verification failed; expected $state but got $observed from $other") unless $result;
hook('after-verify', $result, observed => $observed, expected => $state);
$result;
__
meta::function('vim', <<'__');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__
meta::hook('before-shell::ad', 'ad(\'section::\');');
meta::indicator('cc', 'length ::retrieve(\'data::current-continuation\') ? "\\033[1;36mcc\\033[0;0m" : \'\';');
meta::indicator('locked', 'is_locked() ? "\\033[1;31mlocked\\033[0;0m" : \'\';');
meta::indicator('path', <<'__');
my @highlighted = map join("\033[1;30m|\033[0;0m", split /\|/, $_), @{$transient{path}};
join "\033[1;30m/\033[0;0m", @highlighted;
__
meta::internal_function('around_hook', <<'__');
# around_hook('hookname', @args, sub {
#   stuff;
# });

# Invokes 'before-hookname' on @args before the sub runs, invokes the
# sub on @args, then invokes 'after-hookname' on @args afterwards.
# The after-hook is not invoked if the sub calls 'die' or otherwise
# unwinds the stack.

my $hook = shift @_;
my $f    = pop @_;

hook("before-$hook", @_);
my @result = &$f(@_);
hook("after-$hook", @_, @result);
wantarray ? @result : $result[0];
__
meta::internal_function('associate', <<'__');
my ($name, $value, %options) = @_;
die "Namespace does not exist" unless exists $datatypes{namespace($name)};
$data{$name} = $value;
execute($name) if $options{execute};
$value;
__
meta::internal_function('attribute', <<'__');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__
meta::internal_function('attribute_is', <<'__');
my ($a, %options) = @_;
my %inherited     = parent_attributes(grep /^parent::/o, sort keys %data) if grep exists $options{$_}, qw/-u -U -d -D/;
my $criteria      = $options{'--criteria'} || $options{'--namespace'} && "^$options{'--namespace'}::" || '.';

my %tests = ('-u' => sub {! $inherited{$a}},
             '-d' => sub {$inherited{$a} && fast_hash(retrieve($a)) ne $inherited{$a}},
             '-i' => sub {$transient{inherit}{namespace($a)}},
             '-v' => sub {$transient{virtual}{namespace($a)}},
             '-p' => sub {$a =~ /^parent::/o},
             '-s' => sub {$a =~ /^state::/o},
             '-m' => sub {$a =~ /^meta::/o});

return 0 unless scalar keys %tests == scalar grep ! exists $options{$_}    ||   &{$tests{$_}}(), keys %tests;
return 0 unless scalar keys %tests == scalar grep ! exists $options{uc $_} || ! &{$tests{$_}}(), keys %tests;

$a =~ /$_/ || return 0 for @{$options{'--path'}};
$a =~ /$criteria/;
__
meta::internal_function('cache', <<'__');
my ($name, %pairs) = @_;
if (%pairs) {associate("cache::$name", join "\n", map {$pairs{$_} =~ s/\n//g; "$_ $pairs{$_}"} sort keys %pairs)}
else        {map split(/\s/, $_, 2), split /\n/, retrieve("cache::$name")}
__
meta::internal_function('chmod_self', <<'__');
my ($mode_function)      = @_;
my (undef, undef, $mode) = stat $0;
chmod &$mode_function($mode), $0;
__
meta::internal_function('dangerous', <<'__');
# Wraps a computation that may produce an error.
my ($message, $computation) = @_;
terminal::info($message) if $message;
my @result = eval {&$computation()};
terminal::warning(translate_backtrace($@)), return undef if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('debug_trace', <<'__');
terminal::debug(join ', ', @_);
wantarray ? @_ : $_[0];
__
meta::internal_function('execute', <<'__');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{$datatypes{$namespace}}(attribute($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__
meta::internal_function('exported', <<'__');
# Allocates a temporary file containing the concatenation of attributes you specify,
# and returns the filename. The filename will be safe for deletion anytime.
my $filename = temporary_name();
file::write($filename, cat(@_));
$filename;
__
meta::internal_function('extension_for', <<'__');
my $extension = $transient{extension}{namespace($_[0])};
$extension = &$extension($_[0]) if ref $extension eq 'CODE';
$extension || '';
__
meta::internal_function('fast_hash', <<'__');
use Digest::SHA qw/sha256_base64/;
sha256_base64(@_);
__
meta::internal_function('file::nuke', <<'__');
# Nukes a file with the preferred mechanism.
my ($file)  = @_;
my $backend = eval {file_nuke_backend()} // 'shred';
return system("shred -u '$file'") if $backend eq 'shred';
return unlink $file if $backend eq 'unlink';
die "unknown file::nuke backend: $backend";
__
meta::internal_function('file::read', <<'__');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__
meta::internal_function('file::write', <<'__');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

my $open_name = $name =~ /^[>|]/ ? $name : $options{append} ? ">> $name" : "> $name";
open my($handle), $open_name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__
meta::internal_function('fnv_hash', <<'__');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__
meta::internal_function('hypothetically', <<'__');
# Allows you to make changes to the data without committing them.
# Usage:
#
# hypothetically(sub {
#   ...
# });
#
# Changes to %data made inside the sub {} are discarded.

my %data_backup   = %data;
my ($side_effect) = @_;
my @result        = eval {&$side_effect()};
%data = %data_backup;

die $@ if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('internal::main', <<'__');
disable();

$SIG{'INT'}              = sub {snapshot_if_necessary(); exit 1};
$transient{initial}      = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action;
my @effective_argv = @ARGV;

unshift @effective_argv, $function_name and $function_name = 'method_missing'
unless exists $externalized_functions{$function_name};

around_hook('main-function', $function_name, @effective_argv, sub {
  dangerous('', sub {
    chomp(my @result = &$function_name(@effective_argv));
    print join("\n", @result), "\n" if @result})});

save() unless state() eq $transient{initial};

END {enable()}
__
meta::internal_function('invoke_editor_on', <<'__');
my ($data, %options) = @_;
my $editor    = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} || die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options   = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $attribute = $options{attribute};
$attribute =~ s/\//-/g;
my $filename  = temporary_name() . "-$attribute$options{extension}";

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
file::nuke($filename);
$result;
__
meta::internal_function('is_locked', '!((stat($0))[2] & 0222);');
meta::internal_function('metadata_from', <<'__');
my ($filename) = @_;
my %metadata;

# Not using file::read because we only need the first few lines.
open my($fh), '<', $filename or return {};
while (<$fh>) {
  $metadata{$1} = $2 if /^#\s*(\w+):\s*(.*)$/;
  last unless /^#/;
}
close $fh;

\%metadata;
__
meta::internal_function('namespace', <<'__');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__
meta::internal_function('parent_attributes', <<'__');
my $attributes = sub {my ($name, $value) = split /\s+/o, $_; $name => ($value || 1)};
map &$attributes(), split /\n/o, join("\n", retrieve(@_));
__
meta::internal_function('parent_ordering', <<'__');
# Topsorts the parents by dependency chain. The simplest way to do this is to
# transitively compute the number of parents referred to by each parent.

my @parents = @_;
my %all_parents = map {$_ => 1} @parents;

my %parents_of = map {
  my $t = $_;
  my %attributes = parent_attributes($_);
  $t => [grep /^parent::/, keys %attributes]} @parents;

my %parent_count;
my $parent_count;
$parent_count = sub {
  my ($key) = @_;
  return $parent_count{$key} if exists $parent_count{$key};
  my $count = 0;
  $count += $parent_count->($_) + exists $data{$_} for @{$parents_of{$key}};
  $parent_count{$key} = $count};

my %inverses;
push @{$inverses{$parent_count->($_)} ||= []}, $_ for @parents;
grep exists $all_parents{$_}, map @{$inverses{$_}}, sort keys %inverses;
__
meta::internal_function('retrieve', <<'__');
my @results = map defined $data{$_} ? $data{$_} : retrieve_with_hooks($_), @_;
wantarray ? @results : $results[0];
__
meta::internal_function('retrieve_trimmed', <<'__');
return strip(retrieve($_[0])) if $transient{trim}{namespace($_[0])};
retrieve($_[0]);
__
meta::internal_function('retrieve_with_hooks', <<'__');
# Uses the hooks defined in $transient{retrievers}, and returns undef if none work.
my ($attribute) = @_;
my $result      = undef;

defined($result = &$_($attribute)) and return $result for map $transient{retrievers}{$_}, sort keys %{$transient{retrievers}};
return undef;
__
meta::internal_function('select_keys', <<'__');
my %options = @_;
grep attribute_is($_, %options), sort keys %data;
__
meta::internal_function('separate_options', <<'__');
# Things with one dash are short-form options, two dashes are long-form.
# Characters after short-form are combined; so -auv4 becomes -a -u -v -4.
# Also finds equivalences; so --foo=bar separates into $$options{'--foo'} eq 'bar'.
# Stops processing at the -- option, and removes it. Everything after that
# is considered to be an 'other' argument.

# The only form not supported by this function is the short-form with argument.
# To pass keyed arguments, you need to use long-form options.

my @parseable;
push @parseable, shift @_ until ! @_ or $_[0] eq '--';

my @singles = grep /^-[^-]/, @parseable;
my @longs   = grep /^--/,    @parseable;
my @others  = grep ! /^-/,   @parseable;

my @singles = map /-(.{2,})/ ? map("-$_", split(//, $1)) : $_, @singles;

my %options;
/^([^=]+)=(.*)$/ and $options{$1} = $2 for @longs;
++$options{$_} for grep ! /=/, @singles, @longs;

({%options}, grep length, @others, @_);
__
meta::internal_function('strip', 'wantarray ? map {s/^\\s*|\\s*$//sgo; $_} @_ : $_[0] =~ /^\\s*(.*?)\\s*$/so && $1;');
meta::internal_function('table_display', <<'__');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map strip(sprintf($format, @$_)), @row_major;
__
meta::internal_function('temporary_name', <<'__');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__
meta::internal_function('translate_backtrace', <<'__');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__
meta::internal_function('with_cwd', <<'__');
my ($dir, $f) = @_;
my $cwd = cwd();

my @result = eval {chdir $dir && &$f()};
chdir $cwd;
die $@ if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('with_exported', <<'__');
# Like exported(), but removes the file after running some function.
# Usage is with_exported(@files, sub {...});
my $f      = pop @_;
my $name   = exported(@_);
my $result = eval {&$f($name)};
terminal::warning("$@ when running with_exported()") if $@;
file::nuke($name);
$result;
__
meta::internal_function('with_fork', <<'__');
my (@args) = @_;
my $f = pop @args;

return process->new($child_pid) if my $child_pid = fork;

# This is the child process. Disable saving to prevent contention, and then
# exit with the given status code.
*::save = sub {};
exit &$f(@args);
__
meta::library('process', <<'__');
package process;

sub new  {my ($class, $pid) = @_; bless \$pid, $class}
sub kill {my ($self, $signal) = @_; ::kill $signal // 'KILL', $$self; $self->wait()}
sub term {my ($self) = @_; $self->kill('TERM')}
sub int  {my ($self) = @_; $self->kill('INT')}
sub stop {my ($self) = @_; $self->kill('STOP')}
sub cont {my ($self) = @_; $self->kill('CONT')}

sub wait {my ($self) = @_; ::wait($$self)}
__
meta::library('shell', <<'__');
# Functions for shell parsing and execution.
package shell;
use Term::ReadLine;

sub tokenize {grep length, split /\s+|("[^"\\]*(?:\\.)?")/o, join ' ', @_};

sub parse {
  my ($fn, @args) = @_;
  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;
  {function => $fn, args => [@args]}}

sub execute {
  my %command = %{$_[0]};
  if (exists $externalized_functions{$command{function}})
    {&{"::$command{function}"}(@{$command{args}})}
  elsif (exists $externalized_functions{'method-missing'})
    {::method_missing($command{function}, @{$command{args}})}
  else
    {die "undefined command: $command{function}"}}

sub run {execute(parse(tokenize(@_)))}

sub prompt {
  my %options = @_;
  my $name    = $options{name} // ::name();

  my $indicators = join '', map &{"::$_"}(), ::select_keys('--namespace' => 'indicator');
  my $prefix     = $transient{repl_prefix} // '';

  "$prefix\033[1;32m$name\033[0;0m$indicators "}

sub repl {
  my %options = @_;

  my $term = new Term::ReadLine "$0 shell";
  $term->ornaments(0);
  my $attribs = $term->Attribs;
  $attribs->{completion_entry_function} = $attribs->{list_completion_function};

  my $autocomplete = $options{autocomplete} || sub {[sort(keys %data), grep !/-/, sort keys %externalized_functions]};
  my $prompt       = $options{prompt}       || \&prompt;
  my $parse        = $options{parse}        || sub {parse(tokenize(@_))};
  my $output       = $options{output}       || sub {print join("\n", @_), "\n" if grep length, @_};
  my $command      = $options{command}      || sub {my ($command) = @_; ::around_hook('shell-command', $command, sub {&$output(::dangerous('', sub {execute($command)}))})};

  length $_ && &$command(&$parse($_)) while ($attribs->{completion_word} = &$autocomplete(), defined($_ = $term->readline(&$prompt())))}
__
meta::library('terminal', <<'__');
# Functions for nice-looking terminal output.
package terminal;

my $process = ::name();

sub message {print STDERR "[$_[0]] $_[1]\n"}
sub color {
  my ($name, $color) = @_;
  *{"terminal::$name"} = sub {chomp($_), print STDERR "\033[1;30m$process(\033[1;${color}m$name\033[1;30m)\033[0;0m $_\n" for map join('', $_), @_}}

my %preloaded = (info => 32, progress => 32, state => 34, debug => 34, warning => 33, error => 31);
color $_, $preloaded{$_} for keys %preloaded;
__
meta::message_color('cc', '36');
meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::parent('/home/spencertipping/r/initiative/perl-objects/tex-document', <<'__');
function::compile-tex          1aU7yfeprcTdi5jtVg9D8qNFN6k5Z10MIwh78OaElOQ
function::tex                  vSLEcsHFFwXuYQU+U92quhZeytY4UGnrRdv/NIRj8f8
meta::externalize_template     99ls6D48caTrj4sNOD5U8kZIVKM+UKGodTsuIdemoow
meta::functor::code-templates  yIgx4ZtSh0bgaqmJf9QLxW0eEzKg6anynKXNrnDaVOU
meta::functor::tex-templates   frgH3U2KUE/bpOnVQdZZ//N8dd96ZudeXZtbfKpSROc
meta::template::beamer         XXhL4W5V+hlDETX71+6RX2r2J3xdvdb3if22e+zlijk
meta::template::code           QEz+0uogL3PayY55ZuU05VMf1KK8GfuHv8wrWKMRnjY
meta::template::document       MHlj293tE0RiuQ2WI/t1F110wHpQBfPQ4GAEvOyLDfY
meta::template::enumeration    jjwylQxn+TR3MxlKLuZxvpxhjKkqO2hWhd8zBOcVjrI
meta::template::math           S0kE11xCtBgTBMqu3Q8qF0zlrm5QWRuwzlXd4rZKS6M
meta::template::quotations     u5BEmXEb3b/YiFJcq7SvL7ppAfeAhkWi+o/LaPYGQnI
meta::template::sections       LYldyfJJTic+/KaBJVR1TYiVqqWTWUZDgxPbFcc0PYo
meta::type::psection           mldc2SZmf1Anc2A9yDHHoFfZi7mEIQmlN1GS5oWheI4
meta::type::resource           5SajN55K0xl4RzLLyWV6x3f8UnBeeSTkFjK55XNlkzw
meta::type::section            4Iq24yQH88Mbx0s0iQ9RERa76GoQpOGP58OogVZdlOQ
parent::preprocessor           3bYtZX99wTeQV5ZjewzxA2urOhHbup7Pa5F4homGuxE
parent::sdoc                   67pQdEUgI5ftzFIxAdEjAQwPyOJbcPa9x8aSPod1N8M
parent::vim-highlighters       Ciu+jISeDhWeNTsgX2XF3ivTuZvxeoERrb0ymgBrnS4
resource::header               TVm38wY1C+uwP+8Id0UxEbk4ZjI/vKtO/cR8kj92WDs
resource::header-languages     kMAe7vlErAnTSSW6JkPQnDQhroDGp4ZNv4wXQGjFH64
resource::header-listings      5TiVUmOp6EaRewZrHVoNVfzYNmq9zxpxvbHDvSzoW3U
resource::header-packages      9lccyZaHHtMC3SK7piGf6p1v+oTBt2vZsud1WKZKHu8
resource::header-refs          Aos0EtTHdFEyT4Rc7Qoc7GREFFUoEFmCWDzVXCmf5A0
resource::header-resource      +eY+XB4HTX0Vxfs2ddkbUJ5knu9Rg1LUYviZVzUmtHY
template::item[]               GCQvcO79cQb6288uEIfPrXlpwKXMgIVMdnr6ikbQYYs
template::label                E8eUUYXvUlcHXcvd6keVzZ1R+WkDeW+2bPehzoO/ktk
template::logical              tXrUGDhma3Ipze3wjdrzzBsX0jUTYGHtIgUscIWJ4eg
vim_highlighter::cltex         C/FTNRGbWC9bPXrKcxnn+DJPiV2BiMbOl/ocJyx/QZA
vim_highlighter::perltex       6QAVunvCpmdozTRbxQxV0k0v8h5rZeVZ3kuD8wwJ/9c
__
meta::parent('object', <<'__');
bootstrap::html                         /9nKOzNlCVjt5KpPCw6ktpNdorICJPOmdsxw8gRbQgs
bootstrap::initialization               TvbsjnluOC8KVyAVtB4a6Yzd+QlZ0Caz+PywmbS+RsE
bootstrap::perldoc                      Yun55m+nTQKU5l0UCuImJQGrDnrhsJ18adHGKgtzQ6M
function::ad                            TDzQEoFVHn4cxoMC1v2lQtvbymt7TDA+fzzf8ZdKBTY
function::alias                         76cEB7oBB2F8XdFTKnJy1lDh45nPgZ0c0xeoQUesLDk
function::cat                           6DwhwhDw7GTCE8Ll4Hwi13L3agMbCK7nbX0tDdC4MNU
function::cc                            YUoFsxNwVjmiHsdz9J7A13fBhp0++EiinFxETzF8+3g
function::ccc                           T3ySqmDsgIDdk55Fm4agtCEe1OOYWihhUcfiPtTupAs
function::cd                            cH/fs1az9tELnBgTC7JW/eb/ZSsf7s+K8Os8cMCeEG8
function::child                         y8XMjuUj//66Rj5jSs4HdEn1SqEIT1UVO6/2zb12Ln8
function::clone                         3ImmJEgQg9iM1gqe/hfKBFBm/Ky0HR/+xWj6XLXF3xk
function::cp                            +586T+V2LWthllDZvvTJzGNtngNo5c1pcS36XgTh1gs
function::create                        EG9exU+k3oTxSMX2TJHp660yAjhAe7+KZd4qBC1+vR8
function::current-state                 BPu6xpOyr3Ns0vYdawRlNxsmeRPITGp1bm0QtMaXFw4
function::cwd                           kUuYtqZpgzhXPJOe4f+SLRCFTG+tNl5j8p7+0yqE6C0
function::disable                       ETVjo3v6gmGncp7YgrEmQiDlF7GTHP0EX3yMOsn0M98
function::edit                          QgBU/tNoicpE+PHlVDKuUZ5vn5Da36GrycIxE0MwbA0
function::edit-self                     CnLk1bZDZ7VYrDQlYzfHXZ1aP5+0FrGCRBU1CUhel5I
function::enable                        uj6pBBIjv0ahKWcnbyL1IU4bsvDQqVJrQt6LrsUMzc4
function::expanded-bootstrap            ngkWm7nFPxTICYZLKkdsabU4dFOpRBuvlpXdJsOvUGU
function::export                        a/OWMZFsFsvHwnlvCBEZMg8WhZ9IP9ZwqJZBj7Garq8
function::extern                        EG6Lhkqo4xNy3xxWJgDv22Ij987xFAYgtwSXWNzwgDw
function::grep                          V4XnzOTDllwCW/e2EMuFITuX/q6stdhIQaCCOPo6ob4
function::hash                          +KkJP3kfAnYIXy1BBSEDdfzhnLpQPqz52RJpwgk+OCc
function::hook                          rhEyOmCy+ZDyO727aPXfTrEtkOOGaGKcezlkYf9BK0k
function::hooks                         2rZQUo7p9iu9gmM4wR+G6/RukNXgAk+ZcFepCgnfef8
function::identity                      6+JeD3ohDjevZF5UG7V3iRFkxIwp4KwwibpVc9dwcm4
function::import                        4TKj8ayYsR8EtPFO+Jv3FK2Rv4j4uTAOC77twB9GBkE
function::initial-state                 E45KKMXa7YYzleuQNeMa+2XTkvSxKw40KaWN0lHLhV0
function::is                            R4wqjFaGUQnk3q8Ru9HEoyuoiTd0nEXs8655T50bO3I
function::load-state                    eLPBMJvlKzYr+6ZrhVj3kwYhpyxc9NS6veacMaV3sLk
function::lock                          rgtPo1uxq+ZA8QVPi2hstfNkbTojY7P7S4KmEwad/J4
function::ls                            qrAno4J3gk8dgDQv2/uX4Tf2Togs4RA6ijzCGuyCS4U
function::mv                            oGOOV1RR5dS32B/rTSJI2w/8FEt7LbMwDfMMZwjpqLY
function::name                          CJWkv4fyzTENKSfoZBLH4yjeaP9YkzqCiNcsULOibaE
function::parents                       PvAkixp0hXE4Q/1z7CKPil5BLkSGdGwMfg6QCGgW0EY
function::perl                          pOOr9RtVKIQI6kNIDkC1HmsIDll4TPio8OM3Cmi3htE
function::rd                            HC6cTSNHAtUtreuzLHKP6HkkDTCgI4gkzTY7t9EO//Q
function::reload                        FK+ITbNziplYOjLH/y5f4MzIJOaq/dQlHJ2CLp3+RDo
function::rm                            EwSp4uAK0uVy4lCYpJYvd0qu12q24rIlEiDUbfcW+YA
function::rmparent                      3RgK0wVGkKinmoqBJ0fZEyv72qWiL6a3unkz3etJC+M
function::save                          k2yC8b9dcIeXDeKmNQbxMY8j7svl4kyLoG+XAJY/E/8
function::save-state                    KyoEB2NXy0ko1IYUVujXqEfbNbsoDckiKjwn8+zjvxs
function::serialize                     C0ZKGKNZKobNO0kmIPR2x0gXt6ic2YkCBCrCWqApodQ
function::serialize-single              bOoEGNxf7jcYMAbvT4n492g5aUQ9e+umiaYC574Re6E
function::sh                            PA9Q/R+AEXXCDtU8QIPNFbZr/iITh4DXEG6EWY6n4DM
function::shb                           /COiQpKD0k/4B4/fnj1q1GtH+Z+ZQV0fJUwX6kSseks
function::shell                         vmp2+XW/dSS4KbXsVcimZAzAuJloTDaQASZgG0Y07Dg
function::size                          UFrBxczp+lDNQsbGtXE7IlZULMMP2NWLqJQsUvHlr1Y
function::snapshot                      zTuPSITfomNBxxegaGuSzov/JMWJ3vUWGqAAbYx/MsY
function::snapshot-if-necessary         V2hG5mBuDkIzwasK2iNJt5v+7iK2yAYD1/Omir19AmM
function::state                         EmD3LgRcBLmEIu1loHDBwhS+F73W0KLjm9mRNws0BVI
function::touch                         MvxEZzMCnQsgc44DzkQmPpuY/gVpZjNIVGgAqznIUPE
function::u                             hxjOve/ti/MyoyBAl/1EkoXIEAB/4bOdIh8eXM3oNJs
function::unlock                        ab+C+O37Wm9wHXqiOaF+0uwd3asIzlcJcChqOpFqiwk
function::update                        67tiKQo3l50gnH1KAXcfUH6tf/tB3K64UEM2lKrcge4
function::update-from                   ZnceaN1aTEkye6SRPhI/eLnjd56gyBdAAC74YAzKkbI
function::usage                         ITBRGF9rUVDwVE+YpFc2XXNeU2tD+IJKuvUGzqp30BA
function::verify                        nRZZh97ekQOHcDQUnxrHxMhybS2RlZifwYbH56KrL3M
indicator::cc                           2ikhlSjKzneE/3j6mqjUwNQe7gyTJ6IP39JuZJXB8ow
indicator::locked                       ZtHtnMoF2VDZ6rNdzy8JHnnrO71UXJgLN+OUoiQr9Fs
indicator::path                         XVIgNhtNzG44gG2fWuZOsKqfInEUa7hFABIN1mkM6S4
internal_function::around_hook          zWPc/eIWZMVUXDctAd/u34J1WA40nlbh8SvBx2tE2VA
internal_function::associate            aRtHj4eVjuRHamUSAHaI9DVezimcdFaqFkva+dz0x7M
internal_function::attribute            T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw
internal_function::attribute_is         O+KJhA7B6+N7gkDV2ajInPi947wIMEDHzAaRvWqB0a0
internal_function::cache                H0Rgkwopfv+3kVOCYBuUrh32L0pwHwBzy3LK6jhG2nU
internal_function::chmod_self           jwP33VbXCB7ZGtZ6rAm3ITeudyt+gq8wdkK/JYFvu8c
internal_function::dangerous            hpmVjFqxl2K7Kn+JMjADIOB4ZRwpsNKjulPWkUnwqng
internal_function::debug_trace          Py4lyrgkcj9TD3WxREcAOIu5qSk5ovMw/NJX/hsezMw
internal_function::execute              u5QsUyqazbIXg102zvkkR9c+U70uoAExjjTtRVss4SI
internal_function::exported             lt+j/oJ17agFjOp8QSeb2GN3j4iwEOqMulXaoAj91rI
internal_function::extension_for        VeNEZFjlo6u8rC3yvntP4xu/xpjW36Rq3PCPqlkjTiI
internal_function::fast_hash            BP8vJF0piDed/aGYR1H8SLjk9XqoGdhjpOH3wqUEFLU
internal_function::file::nuke           vRgROFbL2G7rrwziDIcamYLXWb4Sd6q325jGfqSk1f0
internal_function::file::read           ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg
internal_function::file::write          nMg2QO30cjzzI8/maAYtxQ76Ny3Tn0+67CX7xPkMu64
internal_function::fnv_hash             N2uv6uAkri1qLYjFmFOzWITS8UX0nj29kSN/Y1Z2+MM
internal_function::hypothetically       5h4k5A1NACvCeZF+auxnVnBOTfHvGYMINpFARejGqAA
internal_function::internal::main       MJVtZ4FOaoIiqG+CM+fMjVugUyU7+S6xLeirkoamEzU
internal_function::invoke_editor_on     T6uVYs1mq/VotsBwgqfn3aCoJD6JIG9+jp5M7y38ciw
internal_function::is_locked            EN0WP8v+JfHjxrEUDR5BMAJ4pMfNwj3UgG7zuj3B+yU
internal_function::metadata_from        fdIYuVCLs5te7JJdp7n2GhcSZRhZBp9O9hDdFZ3MV1s
internal_function::namespace            D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug
internal_function::parent_attributes    R4t2hz0vRzfeLwj0BJWd6tIG92nhwgnJ0ghbwM9+074
internal_function::parent_ordering      jYxqyDRm6Gp0MgwofcisBAy0mFiD+TzRO4kGUo0AfW8
internal_function::retrieve             x/cC8A6IVrv7cGYc06LjgxCmn9bXFKUIWx12NXRJP8U
internal_function::retrieve_trimmed     zCzstBKNEuJKINlRSdyhF8TA812YClYWNPh6b3mhtXc
internal_function::retrieve_with_hooks  Ed7iEFKqmGXxS3JPwmygtLjlOhycYvGsGlxNt3m2vk4
internal_function::select_keys          Kpg0B01VaBHfRb1YeI3/J8KpycHwXi1c0VdLNYkagqQ
internal_function::separate_options     qvGsY0MQiEVjugLRXbi/QfHvEI+3kQr+7jDZMbapfX4
internal_function::strip                jnRBmqPwpXGicECRagXsULSsEzBuO19OHHxvE0R4zVA
internal_function::table_display        qe/73ZK9+GlMti8pCl/CPvcJYK5q5moMUiXzDgKqoJg
internal_function::temporary_name       I6v0e9aXFvCgVCeVSb84b22rwrAIOX2ywYdcr44s3Vg
internal_function::translate_backtrace  n8iPtziEsVmBboZKnIsoUXc3mbe1RLOKJFenszUeHus
internal_function::with_cwd             DCrQF2lCsAa/lbEA3i1fimbTRS//b/L4qxicIsxg+Tg
internal_function::with_exported        sFgG++rvoIvOTTIZ2QlxgblZQ7R2W9kHUn48wVvIxXI
internal_function::with_fork            fB68GdZBM7LfsOmfVsCLBv2+blwEpLgg5aXOphf7P7E
library::process                        27/7yTUHKovr2X+dF2BhebepYF81cYQA1z9Ku97kiKk
library::shell                          z9Whrvl2xc4VLK7zIYdiYnODlXqrNXY1h3TWWNip4z4
library::terminal                       Iw5HMLpx/iJYD3QzZEU7GMDAsEGK700ormCZ+biuDz0
message_color::cc                       dqUIh9jxwukwF1VCiZCtgUee4hwltDIVz1JFQeBQMmk
message_color::state                    jgobCtpCFyiG/RKX4lq/mfFDlqlACsvV8g2iAonP8C8
message_color::states                   xoWiybqyNczdKrDqkigaUhyKrzeJVJPQgAcOoA/H9dc
meta::configure                         wNvmS+fdr/xIUde0ah7ZA51enuGxvC34oW+5c+xeXIM
meta::externalize                       SAxyF6wDNTRSGW2MB+K/k5/kvjykbj5X/xtTandqrQI
meta::functor::editable                 YCK6idpseu9YEyQOH/VIRmaixSpD2Fh9/Zae85p3Z5o
meta::type::alias                       GXKpeJdADYWyo/tSo2INXijrQlakqaBtfPEHcOI5BGI
meta::type::bootstrap                   pvkTkoPACRd4InQ7QezB82EYxJJMhbvFZKPGJeN44R0
meta::type::cache                       R/GhPTCblttoS9U3XHP/UnmfQAv3pH9Q4Wt0oCKWTlc
meta::type::data                        r27u83LwuNHMNErij+j31pmG0/YiHc9Cz0JS3g0AKPA
meta::type::function                    +aTLimxYFh3zNR3AwTblpHo32WMmzet3MgkvTQNfU7I
meta::type::hook                        ivXS9PJvGTKPUaGpYgAqV2dam2DMKwIj5GFUBHstKIg
meta::type::inc                         utWgF45+/EOqDQ+Yiez7nwDBcBacz+oxdzX3G6AKxHs
meta::type::indicator                   0kZ6fU5Gw7XVjKac1A6kna6UOwjWiJB2nTtM+bWYFS8
meta::type::internal_function           i5Z/e6riR0QCY6XoP1PZNGqe29wUhWMP2iNbpMakhT0
meta::type::library                     2LKXPuOHFk8JgPJF4c/PDwpbg+jWK4/E+jeZaZd+fQY
meta::type::message_color               pxp5xSe9bUnOdskJ78dpsSeJO17phMFhVyT12w/YCGA
meta::type::meta                        E78aF6OgcaZMsgJiEo3sIPzmwen+ib/V8iFLEE2rHaU
meta::type::parent                      MH85O3I0OH6/ZemosX9G8TmHGyWVcR2TPR9LTp8WldU
meta::type::retriever                   3YDISpeCeZ0ymbeXkLIhryRyK1R7fYA8SZkQxwD1d7c
meta::type::state                       cy3e7h9soIZRo3LkUS85L+6Pz9s2pf4LKBwY7La/YII
retriever::file                         lOSZ5sIxv78zFrly1i7NEp608wPPnFvPLcAwja2WmyI
retriever::global                       RQa5dsjawOzXJqAEeMc1PWKmWZqEZYnEtbseQDph3kk
retriever::id                           uWjP6vgjXeyfpsYSJVVeS5MxmFgSAcyDWvK42znkd9c
retriever::object                       /qBb5wkKa+URfmjZ3iQFnol8IgPV9lF0UOi6PmIfLWw
retriever::perl                         DD0+Y+2YiFJ997xsJ33MrySz5MDYb2FTx9SckMnfgPI
__
meta::parent('preprocessor', <<'__');
function::preprocess           m2lx3y4p2o25GXwhDdVji++Nc/TDAVLTap0dd7EflZ8
meta::type::template           g4/O5GtNM1bJKhesmvljZcmZBe/Du1fbma/8Sf2p9xY
parent::object                 4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
retriever::pp                  9la40Aol4Q7whkseOeOSByfjW/BzvMg4KThB6onv7fw
template::comment              Q0To1pu8fZ9GuKpTR5R85/OUDQPomqhoHvJHDCwklNQ
template::def                  w1j2n7Dtwc1kIhyH4kdYf3PU4/XKDXeL6EQjdZGGMsI
template::eval                 X4oZfu11/AhIuw2x/jZPwNvxUNeU2yhdhmowc9gLPiE
template::failing_conditional  dcTs2GkHghjI0ymFxNUW4jVHnvghSd4o1Unetur07oA
template::include              DO+8i6ZyEffTITDndTmpbIawHeNZNnA+HLUGY72xWO8
template::include!             g1BkMwjb+IPd0bi9wjTM2dx9EQqtMxrgmF7bHPkjA+U
template::pinclude             6mEhgXKTYooU7F1mkKeXK7kMkTF3MfyEbuNYBvrucfI
__
meta::parent('sdoc', <<'__');
function::sdoc            KqTDWyAjS5Q4rG8uAtDSyLQ6Dh6UPi7drVll5ctyfr8
function::sdoc-html       FLAGAgN9dvYdN/ZEKBVtZnBlZjx/MPB36y+NHkiqQ8A
function::sdoc-markdown   9D2GdBMV+yOwSF7SruQbiw/07Wh44y3yOEOdsxptoq8
function::sdoc-packed     eKkwP/gK2szEB/r0/ajr4jTuLNwuJHIhBpIMXSjvyHc
function::sdoc-pod        M0IYmNg1XZ58Nwxsrf6dkaNEJMJtFWkiTwXn98T/JmQ
function::sdocp           /mf9LC4xggw92hItse5u0RHx8hd6T3HCJgPv863vb5s
meta::type::sdoc          QhRTppEkfsRxF/ymQNFO/Lm5eL8zYA0eFw6ytuvlFt8
meta::type::slibrary      hwtjXzvMlFVe+2fnDbwVGjYSPtnu8Q2///1ySncXJy4
parent::object            4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
retriever::code-sdoc      W8giWQGFB5AYBkD20lG+Pco4o4v4IBf6ba39HK7tlws
retriever::html-sdoc      O05S66RLWpugNJ4WdgHuFnFQNVo3AHdCkDyVH94tXVo
retriever::markdown-sdoc  O7mQ7IvSshQWDaiIGHbGLpy8XdDQWGVmBaPFqHfxS5k
retriever::pod-sdoc       hpLmOLKEJWEO9Xi6IldtM/iwNbM7L7qdsQmtw6mYPGg
retriever::sdoc           5iFtjMdcChKamkboF1vxa9cN0eM6GooEPPoxsBM7mgI
retriever::sdoc-packed    YEF5wR10IRAP4RpW2VbXilFpUudDen+A3oOit7iib/A
retriever::sdocp          5Py67HDgLP2JxQXwlARbemwD1B/3OkeXMpEeNBrCnLI
__
meta::parent('vim-highlighters', <<'__');
function::vim                eUhfd6Sep9M3E7FrDV9ftutQ/lyiJDeTcfO+zrvumio
meta::type::vim_highlighter  4B7NW92I4SsTQcUgmXrihu6wI+BiJe2SvV3TYcLAwQU
parent::object               4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
__
meta::resource('header', <<'__');
- include resource::header-packages
- include resource::header-listings

- include resource::header-refs

- include resource::header-languages
- include resource::header-resource
__
meta::resource('header-languages', <<'__');
\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

__
meta::resource('header-listings', <<'__');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__
meta::resource('header-packages', <<'__');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__
meta::resource('header-refs', <<'__');
\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

% Shamelessly swiped from
% http://compgroups.net/comp.text.tex/using-ref-and-label-so-that-ref-points-to-the-l/245066
\makeatletter
\newcommand*{\Label}[2]{%
  \@bsphack
  \begingroup
    \label{#1-original}%
    \def\@currentlabel{#2}%
    \label{#1}%
  \endgroup
  \@esphack
}
\makeatother

__
meta::resource('header-resource', '\\lstnewenvironment{resourcecode}{}{}');
meta::retriever('code-sdoc', <<'__');
# Lets you specify the SDoc extension manually. For instance:
# code.js::sdoc::foo causes sdoc::foo to be SDoc-rendered using Javascript comments.
my ($name) = @_;
return undef unless $name =~ s/^code\.(\w+)::// and defined retrieve($name);
sdoc($name, $1);
__
meta::retriever('file', '-f $_[0] ? file::read($_[0]) : undef;');
meta::retriever('global', <<'__');
# Returns the global data stashed at the end of this perl object
$_[0] eq 'self' ? $global_data : undef;
__
meta::retriever('html-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^html::/sdoc::/ and defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_html($attribute);
__
meta::retriever('id', '$_[0] =~ /^id::/ ? substr($_[0], 4) : undef;');
meta::retriever('markdown-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^markdown(?:\.(\d+))?(\.q)?::/sdoc::/;
my ($adjust, $quote_code) = ($1, $2);
return undef unless defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_markdown($attribute, adjust     => $adjust,
                          quote_code => $quote_code);
__
meta::retriever('object', <<'__');
# Fetch a property from another Perl object. This uses the 'cat' function.
return undef unless $_[0] =~ /^object::(.*?)::(.*)$/ && -x $1 && qx|$1 is '$2'|;
join '', qx|$1 cat '$2'|;
__
meta::retriever('perl', <<'__');
# Lets you use the result of evaluating some Perl expression
return undef unless $_[0] =~ /^perl::(.*)$/;
eval $1;
__
meta::retriever('pod-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^pod(?:\.(\d+))?(\.q)?::/sdoc::/;
my ($adjust, $quote_code) = ($1, $2);

return undef unless defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_pod($attribute, adjust     => $adjust,
                     quote_code => $quote_code);
__
meta::retriever('pp', <<'__');
return undef unless namespace($_[0]) eq 'pp';
my $attr = retrieve(attribute($_[0]));
defined $attr ? preprocess($attr) : undef;
__
meta::retriever('sdoc', 'exists $data{"sdoc::$_[0]"} ? sdoc("sdoc::$_[0]", extension_for($_[0])) : undef;');
meta::retriever('sdoc-packed', <<'__');
return undef unless $_[0] =~ /^sdoc-packed::(.*)$/;
exists $data{"sdoc::$1"} ? sdoc_packed("sdoc::$1") : undef;
__
meta::retriever('sdocp', <<'__');
return undef unless $_[0] =~ /^sdocp::(.*)$/;
exists $data{"sdoc::$1"} ? sdocp("sdoc::$1") : undef;
__
meta::section('business-protocol', <<'__');
- s1 The business protocol | sec:business-protocol
  For various reasons, partly tradition and partly expedience, companies tend
  to have a set of norms that dictate how people work together. From what I've
  been able to observe, the following commandments encode the business
  protocol:

  - enumerate << end
    - item \bf Thou shalt respect other people's time like thine own.
      This is absolutely crucial. Business is about money, people convert money
      to time, and if you waste/take an employee's time then you're wasting the
      company's money. People holding the money to pay your salary want to see
      a positive return on their investment in you, which is undermined if you
      then make other people less productive. {\bf Be the person who makes
      others more productive.}

    - item \bf Thou shalt get things done.
      By this I mean, if someone gives you a task it will be done. They don't
      have to think twice about it. If you hit difficulty, you'll figure it
      out. If you can prove it's impossible, change the problem to be possible
      and explain why you did. {\bf Be the person who gives up last.}

    - item \bf Thou shalt work only when it is productive.
      Work $\ne$ productivity. The two are nearly orthogonal, in fact.
      Understand what is productive at as high a level as you can, and work on
      that stuff. Busywork is worse than doing nothing because you'll be
      unavailable but will be getting nothing done. {\bf Be the person who does
      everything for a reason.}

    - item \bf Thou shalt simplify.
      This is a way to respect people's time. Every problem that comes your way
      should be simpler after it interacts with you. Make things look easy
      because to you they are easy. {\bf Be the person who finds the best
      solution.}

    - item \bf Thou shalt be fluent.
      This goes two ways:~you must communicate flawlessly both with people and
      with computers. Functionally, a programmer is an information channel that
      translates between human intent and computational action. You want this
      channel to be efficient, lossless, and high-capacity. {\bf Be the best
      conduit of intent from people to machines.}

    - item \bf Thou shalt not bikeshed.
      Thou shalt not argue in general, in fact. But if you must, make sure it's
      about an issue that justifies a conversation costing the company more
      than \$100/hour (nearly every conversation is likely to cost this, and
      some will cost far more). {\bf Be the person who cuts through the noise
      and focuses on real problems.}
  - end

  I'll go into more details about how to convey these things during an
  interview later on. For now, though, understand that the above values (or
  similar ones) serve as the conduit by which your skills can be applied to the
  company's problems. If this conduit is missing or sufficiently damaged, your
  skills won't matter.

__
meta::section('coding-interview', <<'__');
- s1 Coding interview | sec:coding-interview
  People tend to assume there are two outcomes for a coding interview:~succeed
  or fail. This is not technically true, however; a third outcome is {\em
  succeed specatularly}, which is what you should do if you have the option,
  and here's why.

  Coding challenge interviewers are usually engineers, and engineers tend to
  like to have answers to questions so they can move on. Because of this,
  they'll try to jump to a conclusion about you as soon as they have enough
  signal to justify it. This conclusion is rarely final, but at least they have
  something to work with if they don't observe anything else.

  The interview question will usually fall into one of two categories, each
  equally expedient. One is stuff like FizzBuzz, which rapidly detects certain
  failure modes. The other is something open-ended that gives you some room to
  be creative. Although these problems can detect failure, they're more often
  about detecting excellence.

  If at any point in the interview process someone decides you're excellent,
  you have a much higher chance of getting an offer. Picasso was excellent and
  his paintings are now worth millions, whereas the guy who paints imitation
  art just like Picasso is broke. Setting a new bar instantly promotes you into
  the class of people who can't be replaced, and this makes it much easier to
  justify further investment in interviewing you.

  - s2 Coding challenge etiquette
    Enjoy the coding challenge. Relish it. This is an opportunity to be asked
    difficult, interesting questions that are designed to be solvable in less
    than an hour. It's break from all the mundane aspects of writing production
    code, and an opportunity to prove to yourself as well as your interviewer
    that you can solve anything that comes your way.

    - itemize << end
      - item Have a language you're really comfortable with. Java is not a bad
        choice for this because it's straightforward and everyone knows it.

      - item Unless the problem is trivial, verbally sketch out your thought
        process. Argue against the approaches you've taken to see if they hold
        up. Don't write any code until you know what you're doing. The goal of
        all this is to demonstrate that your thought process is effective at
        solving problems. Silence followed by perfection also works, but is
        riskier.

      - item Make simplifying assumptions as necessary, but be prepared to undo
        them later. Always mention when you're doing this.

      - item If the problem is unsolvable as stated, change it minimally to
        make it solvable and explain why you need to do this.

      - item If the problem is too vague or ill-specified to even work with,
        talk with the interviewer to work the problem into something you can
        solve. Everyone loses if you walk away from the interview without
        having done anything.

      - item When writing code, use idioms that reflect a considered
        perspective. It should be simple, easy to maintain, well-suited to the
        problem, and generally self-documenting. You should be able to
        intelligently discuss every aspect of your coding style.

      - item Never sweat the small stuff. Nobody cares if you know what the
        deletion method is called on Java's {\tt HashSet} class. Just casually
        mention that you'd look it up.

      - item Never get defensive. If you've made a mistake, fix it quickly (or
        think about it and discuss it) and move on. Any good interviewer will
        understand that people make mistakes, and some will even set up
        questions specifically designed to mislead you. This is all part of the
        interview and it's to see how you take it when things go wrong.
    - end

  - s2 Quick-fail problems
    These are the easiest problems you'll get, so you need to make them look
    easy. Some classic examples:

    - enumerate << end
      - item Write the factorial function.
      - item Write FizzBuzz.
      - item Calculate the sum of numbers in a linked list.
      - item Print the last line of a file (naive solution).
    - end

    Coding style matters, as well as speed and whether you can write them
    without any bugs. I'll go through some solutions of varying quality.

    - s3 FizzBuzz
      Bad solutions indicate a deep lack of understanding of some sort. Any
      competent interviewer will count a solution like this against you:

      - java examples/fizzbuzz-bad.java << end
        pulic int fizz_buzz() {         // "pulic" -- eh; "int" ... ????
        int count = 0;                  // count of what?; also, indent!
        while(true) {                   // forever? why?
        int count2 = count              // "count2"?
        while (count2 > 0) {            // modulus! modulus!
        count2 = count2 - 3;
        }
        int count3 = count;             // ok, this is just silly
        while (count3 > 0) {
        count3 = count3 - 5;
        }
        //check for divisibility
        if (count2 == 0){
        if ( count3 == 0) {
        System.out.println("fizzbuzz");
        }
        else                            // missing open brace, not good
        System.out.println ("fizz");
        }
        else
        if count3 == 0 {
        System.out.println("buzz")
        }
        else {
        System.out.println(count)
        }
        }
        }
      - end

      This, on the other hand, is a solution I would consider to be nearly
      perfect:

      - java examples/fizzbuzz-good.java << end
        for (int i = 1; i < 100; ++i) {
          final boolean by3 = i % 3 == 0;
          final boolean by5 = i % 5 == 0;
          if (by3 && by5)
            println("fizzbuzz");
          else if (by5)
            println("buzz");
          else if (by3)
            println("fizz");
          else
            println(i);
        }
      - end

      Some important differences:

      - itemize << end
        - item Indentation and good style should be habit for you. Code should
          have meaning, not just behavior. Formatting should be absolutely
          consistent (any random-looking inconsistency such as in the bad
          solution above will lead your interviewer to suspect you might be
          junior at writing code, and you really want to avoid this).

        - item Know the nuances and idioms of your language. Java gives you a
          modulus operator, so you should use it here. Use the appropriate
          iteration and decisional constructs.

        - item Draw attention to stuff that matters. Here, most of the space is
          taken up by the condition structure, which is parameterized by two
          variables calculated above. The {\tt for} loop is appropriately
          minimal because it's a standard iteration form that uses a generic
          variable name.

        - item Write the solution to resemble the problem. Here, {\tt by3} and
          {\tt by5} are the two conditions we care about. This makes the {\tt
          if} stack nearly a verbatim translation of the problem statement.
          Because of this, it's very easy to look at the code and be confident
          it does the right thing. These variables are short, descriptive, and
          not generic, which causes them to draw attention without taking up
          much space.

        - item Write hints into your code (as appropriate). I like to use
          {\tt final} to indicate invariance, for example. This is a matter of
          opinion, but anything you can do to make it clear that you're
          thinking about maintainability will work in your favor.
      - end

    - s3 Sum of linked list
      This problem is nice because it has a mediocre solution:

      - java examples/sumlist-mediocre.java << end
        interface OurList {
          int head();
          OurList tail();
        }
        int sum(OurList list) {
          if (list == null)
            return 0;
          else
            return list.head() + sum(list.tail());
        }
      - end

      This is logically correct, terse, and generally well-expressed. But it
      has two big problems. First, it returns an {\tt int} rather than a {\tt
      long} or {\tt double}; this is probably a mistake. Second, and more
      importantly, it requires linear stack space and may cause an overflow.
      Java does not optimize tail calls, but even if it did the recursive call
      here is not in tail position. A much better solution uses iteration:

      - java examples/sumlist-good.java << end
        interface OurList {
          int head();
          OurList tail();
        }
        long sum(OurList xs) {
          long total = 0;
          for (; xs != null; xs = xs.tail())
            total += xs.head();
          return total;
        }
      - end

      Not only is this more reliable, but it's also quite a bit faster and
      follows normal Java idioms more closely. It also creates some
      opportunities to talk about some edge cases. For example, what if the
      list is dynamically generated and very long? The iterative solution is
      ideal here because it loses references to cells it's already processed,
      which allows them to be garbage collected. This means we can
      theoretically process lists of arbitrary length using constant space.

      I also prefer the parameter name {\tt xs} to a word like {\tt list}. {\tt
      xs}, which is prounced, ``exes,'' seems simpler to me than {\tt list}
      does because it refers to a series of things called {\tt x}, and {\tt x}
      is the most generic name for a data value. It also takes up less space,
      which makes it easier to focus on the algorithm structure.

      The {\tt for} loop is a little nonstandard, but the idiom is preserved
      from Java's usual numeric iteration. This means that although someone
      unaccustomed to this type of loop might be confused at first, the usual
      intuition about {\tt for} loops would all apply:~we're moving forward
      through a list until we hit the end, the termination check is the second
      thing, and the increment is the third.

    - s3 Practice problems
      Solutions to these are at \ref{sec:practice-problem-solutions}.

      - enumerate << end
        - item $f(s) = \textrm{true}$ if $s$ is a palindrome. Optimal solution
          is constant space, linear time, 6 lines total. Should take under a
          minute.
        - item $f(xs) = \textrm{true}$ if $xs$ contains a geometric series.
          Solution is constant space, linear time, 15 lines of code. Should
          take less than 5 minutes.
        - item Write a function that counts the words in a string without
          allocating memory. Solution is linear time, 14 lines of code, and
          should take less than 5 minutes.
      - end

  - s2 Algorithm problems
    These usually have a known-best solution, but it's ok not to find it. You
    should of course try, and brush up on all of the usual algorithm and data
    structure stuff before a coding interview in case you get a problem like
    this. Below I go through some example problems. It's been long enough since
    I've seen these that I don't remember the solution.

    By the way, you'll notice the almost complete absence of comments from my
    example code. Most interview problems are simple enough that comments are
    unnecessary. When you're practicing questions like this, write your code
    without comments or blank lines and see how readable you can make it. It's
    ok if you later decide to use comments, but most really good code won't
    require them.

    - s3 Maximum subarray
      - quote << end
        \em
        Given a list of integers, find the offset and length of the subarray
        with the largest sum.
      - end

      - s4 Initial train of thought
        It isn't immediately obvious how to do this, so start by talking
        through a few strategies. One option is to calculate the sum of every
        subarray and find the maximum of those, but it seems slow. These
        subarrays are always made from adjacent elements, though, so maybe we
        can ask something like, ``should I expand out by one.'' In fact, since
        we're just summing stuff, we can expand out anytime we have something
        nonnegative and we'll get a larger, or at least not smaller, sum.

        If I were to start coding now (which would be a mistake), here's what I
        would write:

        - java examples/max-subarray1.java << end
          // return [offset, length]
          int[] subarray(final int[] xs) {
            int nextUntried  = 1;
            int maxSum       = 0;
            int maxSumStart  = -1;
            int maxSumLength = 0;
            for (int i = 1; i < xs.length; i = nextUntried) {
              maxSumStart  = -1;
              maxSumLength = 1;
              while (i + maxSumStart >= 0 && xs[i + maxSumStart] >= 0) {
                --maxSumStart;
                ++maxSumLength;
              }
              i += maxSumStart;
              while (i + maxSumLength < xs.length
                     && xs[i + maxSumLength] >= 0)
                ++maxSumLength;
              nextUntried = i + maxSumLength + 1;
            }
            return new int[] {maxSumStart, maxSumLength};
          }
        - end

        The code is a little awkward, but it isn't terrible. The problem is
        with my thinking:~it's obvious I don't really understand something
        important about the problem. The right move is to continue thinking
        about it.

      - s4 First course correction
        Ok, so what happens when we're expanding and hit a negative number? I
        guess we need to look on the other side to see if there's an even
        larger positive number. That's kind of gross, and bumps us back into
        quadratic time; so let's think about it differently. Suppose we first
        take a running sum of the array; then what are we looking for? Oh!
        We're just finding the max and min of that. The numbers in between
        those extremes collectively have the largest sum.

        Writing code here is a much less serious mistake, but is still
        suboptimal. Here's what I'd say, most likely:

        - java examples/max-subarray2.java << end
          int[] subarray(int[] xs) {
            // modify xs in place (!)
            for (int i = 0, total = 0; i < xs.length; ++i)
              xs[i] = total += xs[i];

            int max = 0;
            int min = 0;
            for (int i = 1; i < xs.length; ++i) {
              if (xs[i] > xs[max]) max = i;
              if (xs[i] < xs[min]) min = i;
            }
            return new int[] {Math.min(min, max),
                              Math.max(min, max) - Math.min(min, max)};
          }
        - end

        This is much better, but it's wrong and still suboptimal. Let's
        continue thinking:

      - s4 Second course correction
        Ok, so how do we do this in code? We could start by summing the array
        in a loop, then check for max and min. Oh, but what if min happens
        after max? I guess we really need the largest min/max gap where the max
        is after the min.

        Do we actually need to sum the array in a loop? We never look backwards
        at stuff we've summed, so really we just need to go through and
        maintain a running total. This is an optimal solution, so coding now
        makes sense:

        - java examples/max-subarray3.java << end
          int[] subarray(final int[] xs) {
            if (xs.length == 0)
              return null;
            int max      = 0;
            int min      = 0;
            int maxValue = xs[0];
            int minValue = xs[0];
            for (int i = 1, sum = xs[0]; i < xs.length; ++i) {
              sum += xs[i];
              if (sum < minValue) {
                minValue = maxValue = sum;
                min      = max      = i;
              }
              if (sum > maxValue) {
                maxValue = sum;
                max      = i;
              }
            }
            return new int[] {min, max - min};
          }
        - end

        This solution feels a little more complicated than the last one, but
        it's conceptually more straightforward (since we're not modifying
        anything) and better-engineered. Just the fact that we're solving it in
        constant space is a consideration that a good interviewer would
        appreciate.

    - s3 Parse simple math
      - quote << end
        \em
        Write a function that takes a string containing a simple expression and
        returns the result. The expression will contain single-digit numbers,
        {\tt +}, and {\tt *}, and should respect precedence.
      - end

      Ok, this is obviously a shunting-yard style problem. We could parse it
      recursive-descent, but that's overkill. All operators are
      left-associative, so we can evaluate as we go. Actually, we can just have
      two constant levels:~the number on the left of a {\tt +} and the current
      product. So our solution is constant-space.

      - java examples/parse-math.java << end
        double parsemath(final String expr) {
          double left  = 0;
          double right = 1;
          for (int i = 0; i < expr.length(); ++i) {
            final char c = expr.charAt(i);
            switch (c) {
              case '+':
                left += right;
                right = 1;
                break;
              case '*':
                break;
              default:
                right *= c - '0';
                break;
            }
          }
          return left + right;
        }
      - end

      I had some doubts about 2/3 of the way through this. I wasn't sure it
      would be ok to add {\tt right} to {\tt left} at the end, since it might
      contain a stray {\tt 1} from either initialization or the {\tt +} case.
      But after some thought I realized it would be ok since we always end
      after seeing a digit. That digit changes the 1 into something meaningful.

      In hindsight, my variable names could be better. {\tt left} and {\tt
      right} are less descriptive than {\tt sum} and {\tt product}. Also, the
      first time through I had forgotten parens after {\tt expr.length}. This
      isn't terrible, but it isn't great either. In my case I was confusing
      Java and Javascript, but an interviewer might assume I was bad at Java
      and confusing strings and arrays.

      One nice part of this solution is \verb|c - '0'|. Using the equivalent
      \verb|c - 0x30| or \verb|c - 48| would be hostile to someone reading your
      code, whereas \verb|c - '0'| gives someone just enough hints that it's
      clear you're not up to anything too complicated.

      Doing things like character-to-number conversion this way tells the
      interviewer you know how characters work and have at least some knowledge
      of ASCII. It's also reminiscent of C-style code, which will usually work
      in your favor in today's hiring culture of very high-level languages and
      app development (it shows perspective, assuming you can also do the
      high-level stuff).

    - s3 Sorted word index
      - quote << end
        \em
        Build the index for a book, sorted by word. Your input is a list of
        $\langle \textrm{word}, \textrm{page} \rangle$ tuples, and the list may
        contain duplicates.
      - end

      We'll need some data structures for this. I'll go ahead and write this up
      the wrong way to illustrate some common mistakes:

      - java examples/sorted-index-bad.java << end
        List index(List tuples) {
          HashMap resultIndex = new HashMap();
          for (int i = 0; i < tuples.size(); ++i) {
            if (!resultIndex.contains(tuples[i].word))
              resultIndex.add(tuples[i].word, new LinkedList());
            resultIndex.get(tuples[i].word).add(tuples[i].page);
          }
          List sortedResult = new ArrayList();
          Iterator iterator = resultIndex.iterator();
          while (iterator.hasNext()) {
            Tuple indexEntry = iterator.next();
            sortedResult.add(indexEntry);
          }
          quicksort(sortedResult);
          return sortedResult;
        }
      - end

      This solution has a lot of problems. For one thing, none of the data
      structures are parameterized. {\em Always parameterize your data
      structures.} There are two reasons you want to do this. First, prior to
      Java 1.5 (a long time ago), Java didn't even have generics. You might
      come across as a Luddite who prefers inferior technologies.

      But more importantly, writing this stuff down tells the interviewer what
      you're thinking. A map of \verb|<Thing, Thing>| doesn't convey your
      intentions very well; its meaning is then defined by what you do to the
      map instead of something intrinsic to it.\footnote{Generics aren't
      intrinsic really, but you get the idea.} Whenever possible, use code to
      document what you're doing. Especially parameters and return types,
      because this gives the interviewer a quick way to correct any
      inappropriate assumptions you might be making.

      Here are some other problems with the code above:

      - enumerate << end
        - item It mixes definition types between interfaces (e.g.~{\tt List})
          and implementations (e.g.~{\tt HashMap}). There are very occasionally
          reasons to do this, but this isn't one of them.
        - item It grossly mishandles {\tt tuples}. Were {\tt tuples} a linked
          list, the function would be quadratic.
        - item {\tt resultIndex} is redundant, misleading, and too long. It
          takes up a huge amount of space inside the {\tt for} loop.
        - item {\tt tuples[i].word} is repeated three times in quick
          succession. Stash this into a short variable.
        - item {\tt sortedResult} is too long.
        - item {\tt iterator} is redundant and too long. The ideal name is
          {\tt it}.
        - item The {\tt while} loop spends a whole line defining a variable
          that's almost as long as the expression it replaces.
        - item {\tt quicksort()} is not only dangerous performance-wise, but
          also not a valid Java function. No Java library function would be
          called this way because Java requires that it be a method call
          (unless you {\tt import static}, but your interviewer might not
          assume you meant that).
      - end

      The code also has some technical issues that I don't think are important
      for an interview:

      - enumerate << end
        - item {\tt Map}s don't support {\tt .add}; the correct method is {\tt
          .put}. Nobody cares. The compiler would catch this immediately. If
          the interviewer makes a big deal about this, find a company with
          better priorities or more competent interviewers.

        - item {\tt tuples[i]} doesn't work. This is fine; you clearly want to
          get-by-position. The only thing the interviewer should care about
          here is that this retrieval is linear-time for a {\tt LinkedList},
          and you should know this cold and have a very good excuse for doing
          it this way.

        - item {\tt .size()} could be expensive, but isn't. Your interviewer
          may not have read the source for {\tt LinkedList}, but there's a
          counter in there that makes {\tt .size()} a constant-time operation.
          It's cool if you can work this into an interview, but odds are that
          if you're counting a linked list you're already doing something
          wrong.
      - end

      Here's the right way, with some notational liberties that are appropriate
      during an interview:

      - java examples/sorted-index-good.java << end
        SortedMap<String, List<Integer>> index(final List<Tuple> tuples) {
          final SortedMap<...> result = new TreeMap<>();
          for (final Tuple t : tuples) {
            if (result.containsKey(t.word))
              result.get(t.word).add(t.page);
            else
              result.put(t.word, new ArrayList<Integer>(t.page));
          }
          return result;
        }
      - end

      \verb|SortedMap<...>| isn't allowed, but it's really obvious what I mean,
      especially if I explain it as I'm typing. The same thing is true of
      \verb|new ArrayList<Integer>(t.page)|, which actually is valid Java but
      doesn't mean what I want it to (in real life it sets the initial capacity
      of the list). In an interview I would either make a point of mentioning
      this redefinition, or would just write out the right code.

      It's worth mentioning that I'm being a little more pedantic than
      necessary about a few things. In particular, an interviewer is unlikely
      to care much whether you use {\tt containsKey} vs {\tt contains} and
      stuff like that. Knowing these details adds a bit to your credibility,
      and it's something I try to do, but it won't ever be the difference
      between passing and failing an interview.

  - s2 High-level design questions
    These are usually problems for which you don't write code, but instead just
    describe how you would design a solution. Failure and success are more
    nebulous here, but generally there are two ways to fail one of these
    questions:

    - enumerate << end
      - item The problem has a well-known solution and you completely miss it.
      - item You fail to convince the interviewer that you could actually solve
        the problem given enough time.
    - end

    An example of the first failure mode would be something like, ``design a
    data structure that lets me get the minimum and maximum elements in $O(log
    n)$ time'' and you don't think of either a sorted list or a binary tree.
    You might be able to recover if you invent either one, but it's better (and
    far more reassuring to the interviewer) if you just know how they work.

    The second failure mode happens either when you're completely out of your
    depth, or when you don't adopt the ``give up or die trying'' mentality
    thoroughly enough. If you're good at interviewing, neither should happen to
    you, and here's why. Being out of your depth isn't a dealbreaker if you're
    sufficiently resourceful and/or curious. If you don't have a clue, start
    asking definitional questions until the problem makes a little more sense.
    For example:

    - quote << end
      \em
      How many bits of entropy are in each word in English?

      ``Can I ask a question?'' \\
      ``Sure, go for it.'' \\
      ``What is entropy?'' \\
      ``Entropy is information content, measured as Shannon Entropy.'' \\
      ``Do you mind if I look this up on Wikipedia?''
    - end

    You'll probably get mixed responses to the Wikipedia question. But it's a
    good question to ask because it shows that you know how to teach yourself
    to solve problems you can't yet work with. If the interviewer says yes you
    should be all set, but let's suppose they say no:

    - quote << end
      \em
      ``Nope, you've got to solve this problem with no external resources.'' \\
      ``Ok, I think I can solve this problem but not with just what I know. Can
        you relate entropy to other units of measure?'' \\
      ``I guess you can think of entropy as the log of probability.'' \\
      ``Aha, so we're looking at words in terms of their probability
        distribution.'' \\
      ``That's right.'' \\
      ``Ok, so I guess more common words are less informative because they
        appear more often. Does this mean they have lower entropy?''
    - end

    This is naive and misguided question, but it forces the interviewer to
    either fix your thinking or be pathologically unhelpful. This is exactly
    the situation you want to create when you're operating at a disadvantage.
    Here's one way the conversation can proceed:

    - quote << end
      \em
      ``Well, a word by itself doesn't have entropy; it's a property of the
        probability distribution.'' \\
      ``Interesting, so we don't know the information content of a single
        word.'' \\
      ``That's right, because you need to consider its context to know how
        common it is.'' \\
      ``Ok, so entropy must have something to do with how the probabilities
        themselves are distributed.''
    - end

    And so on. When the interviewer is your only source of information, it's
    critical to keep the conversation going and maintain enough curiosity to
    find your way around the problem space. Interviews are conversations as
    much as they are anything else, and how you think is as important as the
    knowledge you bring to the table.

    It's worth noting that in order for this to work, you need to have a fairly
    broad base of knowledge to tie things to. The interviewer has neither the
    time nor inclination to teach you computer science or math from the ground
    up, so you have to be making some intelligent connections for them to be
    remotely confident that you'll work out.

    - s3 IO scheduler
      - quote << end
        \em
        You're writing an operating system and inventing your own IO scheduling
        strategy. How would you design it?
      - end

      This is a really open-ended question, but you'll get those sometimes.
      Here's how a good interview might go:

      - quote << end
        \em
        ``Ok, so we're scheduling programs' requests to make IO?'' \\
        ``That's right.'' \\
        ``Ok. These programs can read and write, and let's treat each request
          as having an offset and length from the device.'' \\
        ``Yep, you can assume that.'' \\
        ``I guess each program should have its own IO priority. So stuff like
          databases can get first access when it needs to.'' \\
        ``Can you see anything that might go wrong if you do it this way?'' \\
        ``Well, theoretically we might swap to disk, and that's probably being
          scheduled too. But then, maybe we just say that it's inadvisable to
          deprioritize the swapper.'' \\
        ``Fair enough.'' \\
        ``Ok, so every process is going through the same scheduler. I guess the
          question now is what to do at any given moment. Let's keep a priority
          queue of requests.'' \\
        ``How do you sort the queue?'' \\
        ``Program priority.... oh, and we also need to prevent starvation I
          guess. There's probably a standard way of dealing with this.'' \\
        ``There is, but suppose you're inventing it from scratch.'' \\
        ``Ok, well one way to do it is to keep track of the request times. As
          requests get older, they get bumped up the queue even if they're
          technically lower priority.'' \\
        ``That sounds reasonable. What would that sorting function look like?''
        \\
        ``I guess it would be something like $priority + k(delay)$?'' \\
        ``How might that function not do what you want?'' \\
        ``I'm not sure. I guess if $k$ is really small it would still allow
          starvation. But older requests will still outweigh new ones
          eventually.'' \\
        ``Stepping back, what are some other considerations you might want to
          make in your scheduler?'' \\
        ``Let's see...~we're handling priority correctly, so I'm not sure.''
        ``Ok, here's a hint. Suppose you've got two programs running at the
          same priority. One of them is writing 10GB in 4MB chunks, and the
          other one is writing all over the place in tiny 4KB chunks. What's
          going to happen here?'' \\
        ``Oh, that's awful. The random writer is going to introduce all kinds
          of seek delays into the sequential one. I should have thought of
          that.'' \\
        ``Yep, exactly. What do you think is ideal behavior in this scenario?''
        \\
        ``I'm not quite sure. Intuitively it seems like we should let the
          sequential one run uninterrupted for a while, but then what if you
          have two such processes? At that point you're balancing sequential
          access against delays.'' \\
        ``Right, it's a tradeoff between latency and throughput. Is that a
          problem?'' \\
        ``I guess it isn't; that could be a system-wide preference.'' \\
        ``Right. So any ideas about the sequential process?''
      - end

      And so forth. Even though the interviewer had to prompt and give hints,
      it was mostly just to direct the conversation, not because the candidate
      was messing stuff up. Some stuff the candidate did right:

      - itemize << end
        - item Scoped out the problem before trying to solve it. The problem as
          stated actually wasn't solvable because it was underspecified, but
          the candidate asked enough questions to get something tractable.

        - item Recognized that real-world constraints applied to the problem
          and used them (e.g.~mentioning disk swapping). Not all problems are
          amenable to this kind of reasoning, but this one is.

        - item Pointed out that the problem was most likely solved already.
          This is a good thing to do because the interviewer might immediately
          cut over to asking about established solutions. If you don't offer an
          existing solution, an interviewer might suspect you reinvent the
          wheel too eagerly.

        - item Described the solution at the same level of detail as the
          interviewer constrained the problem. The candidate didn't burst into
          code or mention direct memory access. Either of these would be
          addressed at a different level of problem, and the candidate's job is
          to recognize this.

        - item Remained willing to change the solution's design. Because the
          problem isn't written down anywhere, it's going to change constantly
          until the interview ends. It's important to treat it this way and not
          commit to anything too low-level. You want to remain as agile as the
          interviewer.
      - end

      I tried to write an example of a bad interview, but I couldn't figure out
      how the conversation would actually go. A lot of times a bad interview is
      just someone who gets very quiet, or who doesn't understand the
      interviewer and doesn't then ask questions to fix it. A curious person
      who's sufficiently out of the loop might still fail a question like this,
      but odds of success go way up if you stay engaged.

  - s2 Practice problem solutions | sec:practice-problem-solutions
    - enumerate << end
      - item Return true if palindrome.

        - java solutions/palindrome.java << end
          boolean palindrome(final String s) {
            for (int i = 0, j = s.length() - 1; i < j; ++i, --j)
              if (s.charAt(i) != s.charAt(j))
                return false;
            return true;
          }
        - end

      - item Return true if geometric series.

        - java solutions/geometric.java << end
          boolean geometric(final double[] xs) {
            if (xs.length < 2)
              return true;
            if (xs[0] == 0) {
              for (int i = 0; i < xs.length; ++i)
                if (xs[i] != 0)
                  return false;
              return true;
            }

            final double ratio = xs[1] / xs[0];
            for (int i = 2; i < xs.length; ++i)
              if (Math.abs(xs[i] / xs[i - 1] - ratio) > EPSILON)
                return false;
            return true;
          }
        - end

      - item Return the word count of a string without allocating memory.

        - java solutions/wordcount.java << end
          int wordcount(final String s) {
            boolean inWord = false;
            int     words  = 0;
            for (int i = 0; i < s.length(); ++i) {
              final char c = s.charAt(i);
              if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
                if (!inWord)
                  ++words;
                inWord = true;
              } else
                inWord = false;
            }
            return words;
          }
        - end
    - end

__
meta::section('main', <<'__');
- documentclass article
- include resource::header

- title  Interviewing in Ten Minutes
- author Spencer Tipping

- document << end
  - maketitle
  - tableofcontents

  \section*{About this guide}
  Over the past few years I've worked for a lot of startups. (Because I
  job-hopped, not because I'm important.) For one reason or another, I ended up
  conducting technical interviews at about half of these companies. Usually we
  were looking for developers who knew some high-end functional language, so
  this guide is strongly biased by that -- though I think it also applies to
  more standard startup jobs.

  {\bf Everything in this guide is my own opinion.} It does not reflect the
  views of any of my employers, past or present.

  - include section::business-protocol
  - include section::the-interviewer
  - include section::resume
  - include section::technical-phone-interview
  - include section::coding-interview
- end

__
meta::section('resume', <<'__');
- s1 The r\'esum\'e and cover letter | sec:resume
  At \$100, a phone screen is still fairly cheap. The stakes of a resume and
  cover letter are not usually very high, nor is there very much signal for the
  interviewer to work with. However, if you're about optimizing stuff (and
  what engineer isn't?), there are a few things you can do to communicate at
  this point:

  - enumerate << end
    - item \TeX{} your resume. There's only upside here, and it's a nice
      positive signal that you know what you're doing. If you don't know
      \TeX{}, use HTML and export as PDF. If all else fails, write one in plain
      text and claim that minimalism is a social virtue you take seriously.
      Don't use Word because it conveys that you have no standards. As a
      colleague of mine once said, ``if I'm on the fence and the resume is a
      word doc, I typically reject the candidate.'' {\bf Use a spellchecker.}

    - item Keep your resume down to one page. This shows that you respect their
      time. {\bf Use a spellchecker.}

    - item Write a purposeful but informal cover letter. Be personable,
      reasonably enthusiastic, and talk about how the stuff you do for fun is
      relevant to the company's hard problems. {\bf Use a spellchecker.}

    - item Link to your github profile. If you don't have one yet, create one
      and upload something. If you don't have anything to upload, start solving
      Project Euler and upload that. {\bf Use a spellchecker.}

    - item Put some code in your cover letter. Nothing elaborate, but just
      something you thought was cool, or maybe a challenge problem they have on
      their website, or something. Do this only if it makes sense, but it's a
      great opportunity if you can. {\bf Use a spellchecker.}

    - item Link to a project you worked on that really describes who you are.
      {\bf Use a spellchecker.}
  - end

  There are a few things you absolutely cannot do:

  - enumerate << end
    - item Talk about salary in any way. It's just too early and it sends the
      wrong message. It would be like someone asking about your finances before
      the first date. This is a question you ask when you're considering
      marriage, not dinner.

    - item Lie. If you're called out on it, you're done for and people will
      hate you. Word might get around to other companies if you're unlucky. If
      the truth isn't good enough, fix the truth.

    - item Be noticeably unprofessional. Startups aren't overwhelmingly formal
      places, but they're just as vulnerable to harrassment lawsuits as anyone
      else. You do not want to give anyone reason to believe that you're going
      to cause legal problems or alienate people.

    - item Bring politics or religion to the table. These topics are emotional
      catalysts with no upside and enormous potential for problems. Brendan
      Eich, the inventor of Javascript, was forced to resign as CEO of Mozilla
      because he had made a \$1000 contribution against gay marriage six years
      prior. If you have public political statements on a blog or elsewhere,
      take them down.
  - end

__
meta::section('technical-phone-interview', <<'__');
- s1 The technical phone interview | sec:technical-phone-interview
  At this point you have cost the company \$110 or so, and they're deciding
  whether or not to bump that figure by a factor of 10. This is real money, so
  the burden is on you to convince the interviewer (who may or may not be good
  at interviewing people) that you're the best bet they'll make this year.
  Depending on the job you're applying for, there are a few different ways to
  do that.

  In this section I'm going to assume the technical interview is just talking
  on the phone. The next section is entirely devoted to how to handle a
  collaborative coding interview.

  - s2 Technical literacy
    This is an absolute must. At a minimum, you need to be able to answer
    questions like these with little or no thought:

    - itemize << end
      - item Write the FizzBuzz function.
      - item Reverse an array in place.
      - item Reverse a linked list in linear time.
      - item What is the insertion time for a binary tree?
      - item What is the insertion time for a hashtable (worst, average)?
      - item How is a priority queue implemented?
      - item Quicksort vs mergesort, pros/cons?
      - item What does $O(n^2)$ mean formally?
      - item What does ``atomic'' mean?
      - item What is memoization?
      - item Why do floating-point computations often use an epsilon?
      - item How are negative integers represented?
      - item Write the Fibonacci function without using recursion.
      - item What's the difference between the stack and the heap?
      - item Conceptually, what does a garbage collector do?
      - item Conceptually, how does virtual memory work?
      - item What happens under the hood when you go to {\tt google.com}?
      - item Why should you profile before optimizing?
      - item What is an example use case for a cache?
      - item How would you do [some simple task] in a UNIX shell?
    - end

  - s2 Development literacy
    This is also important, especially if you're applying for a position that
    requires experience. You should be able to speak intelligently about things
    like:

    - itemize << end
      - item The bugs you most commonly write, and habits you've developed to
        avoid them.
      - item How expensive it is to fix a bug in production.
      - item Strengths and weaknesses of unit testing.
      - item The drawbacks of using powerful languages like Lisp. (You can
        extol their virtues too, but if that's all you do then people are
        unlikely to take you very seriously.)
      - item Your preferences about design and documentation, and why you do it
        this way.
      - item A project you've worked on that went really well, and why this
        happened.
      - item A project you've worked on that was a disaster, and why. Don't try
        to blame other people; you need one where you messed up and learned
        something. If you don't have a project like this, think of something
        really hard, try to solve it, push the failed results to Github, and
        talk about why that didn't work. It's fine if failure was inevitable;
        the main thing is to know how to translate it into improvement.
    - end

__
meta::section('the-interviewer', <<'__');
- s1 The interviewer | sec:the-interviewer
  Interviewers are not usually sadists. While the case could be made that the
  job demands a certain degree of malevolence, most of the confrontation during
  the interview is due to the economics underlying hiring.

  Consider the common flow of resume screen, phone screen, and then in-person
  interviews. There's a progression of risk/cost associated with moving forward
  at each stage:~screening a resume requires minutes, a phone interview
  requires an hour, and an in-person interview requires several people-hours,
  possibly with hotel and airfare. In dollar amounts, these could easily
  represent investments of \$10, \$100, and \$1000.\footnote{I've been told by
  that in-person interviews can cost significantly upwards of \$1000, so take
  these numbers with a grain of salt and treat them as lower bounds.} The worst
  case, a bad hire, costs potentially \$10,000 or more.

  Given this, the interviewer operates as an investor of the company's
  assets.\footnote{Unlike most investors, however, their pay is constant; so
  they don't have a stake in the outcome of the interview. This creates a
  slight negative bias, but as far as I know it shouldn't influence their
  decisions otherwise.} Their job is to evaluate risks for the company by
  making bets on people. Because of this, if you are an interviewee, your job
  is to sell such a bet to the person interviewing you. Perhaps more to the
  point, the interviewer is likely to be conservative because they don't get
  paid commission; so your goal is to be so awesome that they feel safer saying
  yes than no.

  - s2 Aside:~interview attire
  {\bf The interviewer does not care what you wear to an interview.} Nobody
  cares about this except you. Unlike in almost any other industry, a suit is
  much more likely to be a liability than anything else. I have gotten every
  job I've had by going to interviews in flip-flops, khakis, and a T-shirt, and
  being very comfortable because I this is what I'm used to wearing. The
  interview is about your mind, so give your mind the least-distracting
  atmosphere possible so it can do its job.

  It makes perfect sense if you think about the interviewer's position. If
  you're awesome, the interviewer cannot go back to the hiring manager with an
  assessment like, ``well, the candidate is the most productive we've ever
  seen, but can we really put up with someone who dresses that way?''
  ``Fashion-aware'' and ``software developer'' don't even belong in the same
  sentence. The interviewer will probably say something like, ``the candidate
  blew us away on the coding tests, {\em and this one even wore pants!}''
  ``Capable {\em and} pants? Hire.''

  The flip side is equally clear. If you're awkward and uncomfortable, the
  interviewer doesn't know whether it's because you're having trouble with the
  problems, or whether it's that you're wearing a suit to an office with a beer
  pong table and a CEO dressed in a hoodie. The interviewer is certainly not
  going to say, ``well, that candidate can't code his way out of paper bag but
  man is he a sharp dresser. I'm a yes.''

__
meta::template('comment', '\'\';     # A mechanism for line or block comments.');
meta::template('def', <<'__');
# Define a new template. Analogous to the C preprocessor's #define directive.
# For example:
#
# - def foo x, y, z << end
#   hello $x, $y, and $z!
#   This is an ${x}message.
# - end
#
# You can then use that template immediately:
#
# - foo 3, 4, 5
#
# Interpolation is achieved by evaling a Perl heredoc; the usual caveats apply.
# A variable called $body is automatically bound to the body contents if there
# are any; for example:
#
# - def named x << end
#   name $x {
#   $body
#   }
# - end
#
# - named 'foo' << end
#   woohoo
# - end
#
# You can define a "plural" form like this:
#
# - def -p say_hi_to << end
#   Hi $_!
# - end
#
# - say_hi_to Foo, Bar, Baz
#
# Plural forms still have the $body variable (which doesn't change across
# arguments), but they can't take formal parameters.

my ($options, $name, @args) = separate_options(split /\s+/, $_[0]);
my @formals                 = map split(/,\s*/), @args;
my $body                    = $_[1];

my $formal_list             = join(', ', map "\$$_", @formals);
my $parameter_bindings      = "my ($formal_list) = split /,\\s*/, \$_[0]";
my $body_binding            = "my \$body = \$_[1]";
my $heredoc_delimiter       = state();

# This will work great unless you put large hexadecimal barewords on otherwise
# blank lines in your code. At that point there's a 2^-128 chance that it will
# bomb out horribly.
my $plural = $$options{'--plural'} || $$options{'-p'};

die "- def $name: cannot use formal parameters with the -p option"
if $plural && @formals;

$plural ? meta::externalize "template::$name", "- def -p $name",
            eval "sub {\n$body_binding;\n" .
                 "join \"\\n\", map <<$heredoc_delimiter, " .
                                    "split /,\\s*/, \$_[0];\n" .
                 "$body\n" .
                 "$heredoc_delimiter\n}"

        : meta::externalize "template::$name", "- def $name @formals",
            eval "sub {\n$parameter_bindings;\n$body_binding;\n" .
                 "<<$heredoc_delimiter\n$body\n$heredoc_delimiter\n}";

die $@ if $@;

# No output from this template.
'';

__
meta::template('eval', <<'__');
my ($line, $block) = @_;
if (length $block) {
  my $result = eval $block;
  die "failed to template::eval $block (line was $line): $@" if $@;
  $result;
} else {
  my $result = eval $line;
  die "failed to template::eval $line: $@" if $@;
  $result;
}

__
meta::template('failing_conditional', <<'__');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::warning("eval of template condition failed: $@") if $@;
$should_return;
__
meta::template('include', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__
meta::template('include!', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_) // die "include!: not found: $_",
               split /\s+/, $commands;

__
meta::template('item[]', <<'__');
my ($line, $block) = @_;
my ($name, $label) = split /\h*\|\h*/, $line, 2;
"\\item[$name]" . template::label($label)
                . (length $block ? "\n$block" : '');

__
meta::template('label', <<'__');
my ($line) = @_;
my ($tex_label, $nominal_label) = split /\h*\|\h*/, $line;

length $nominal_label ? "\\Label{$tex_label}{$nominal_label}"
                      : "\\label{$tex_label}" if length $line;

__
meta::template('logical', <<'__');
# Creates a logical section that is delimited only by TeX comments.
my ($name, $body) = @_;
$body =~ s/^\s*(.*\S)\s*$/\1/;
"% ${name}\n$body";

__
meta::template('pinclude', <<'__');
# Just like the regular include, but makes sure to insert paragraph boundaries
# (this is required for SDoc to function properly).

my ($commands) = @_;
return '' if template::failing_conditional($commands);
my $text = join "\n\n", map retrieve($_), split /\s+/, $commands;
"\n\n$text\n\n";
__
meta::vim_highlighter('cltex', <<'__');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX with support for a bunch of embedded languages)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match   cltEofMarker      /<<\s*\w\+/ contained
syn region  cltLineComment    matchgroup=cltCode start=/^\s*- comment / end=/$/ contained
syn region  cltLogicalComment matchgroup=cltCode start=/^\s*- logical / end=/<</ contained
syn match   cltLine           /^\s*- .*$/ contains=cltEofMarker,cltLineComment,cltLogicalComment

syn case match | syn include @cpp           syntax/cpp.vim        | unlet b:current_syntax
syn case match | syn include @java          syntax/java.vim       | unlet b:current_syntax
syn case match | syn include @asm           syntax/asm.vim        | unlet b:current_syntax
syn case match | syn include @javascript    syntax/javascript.vim | unlet b:current_syntax
syn case match | syn include @html          syntax/html.vim       | unlet b:current_syntax
syn case match | syn include @perl          syntax/perl.vim       | unlet b:current_syntax
syn case match | syn include @ruby          syntax/ruby.vim       | unlet b:current_syntax
syn case match | syn include @python        syntax/python.vim     | unlet b:current_syntax

syn case match

syn region  cltCpp         matchgroup=cltCode start=/^\z(\s*\)- cpp .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@cpp
syn region  cltJava        matchgroup=cltCode start=/^\z(\s*\)- java .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@java
syn region  cltAsm         matchgroup=cltCode start=/^\z(\s*\)- asm .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@asm
syn region  cltJavascript  matchgroup=cltCode start=/^\z(\s*\)- javascript .*<<\s*\z(\w\+\)$/ end=/^\z1- \z2$/ contains=@javascript
syn region  cltHtml        matchgroup=cltCode start=/^\z(\s*\)- html .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@html
syn region  cltPerl        matchgroup=cltCode start=/^\z(\s*\)- perl .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@perl
syn region  cltRuby        matchgroup=cltCode start=/^\z(\s*\)- ruby .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@ruby
syn region  cltPython      matchgroup=cltCode start=/^\z(\s*\)- python .*<<\s*\z(\w\+\)$/     end=/^\z1- \z2$/ contains=@python
syn region  cltResource    matchgroup=cltCode start=/^\z(\s*\)- resource .*<<\s*\z(\w\+\)$/   end=/^\z1- \z2$/
syn region  cltComment     matchgroup=cltCode start=/^\z(\s*\)- comment .*<<\s*\z(\w\+\)$/    end=/^\z1- \z2$/

syn cluster cltStuff       add=cltCpp,cltJava,cltAsm,cltJavascript,cltHtml,cltResource,cltComment,cltLine,cltPerl,cltRuby,cltPython

syn region  cltDocument    start=/\%^/ end=/\%$/ contains=@cltStuff

hi link cltLine            Special
hi link cltKeyword         String
hi link cltResource        String
hi link cltEofMarker       String

hi link cltCode            Special
hi link cltDocument        Comment
hi link cltComment         Type
hi link cltLineComment     Type
hi link cltLogicalComment  Type

let b:current_syntax = "cltex"

__
meta::vim_highlighter('perltex', <<'__');
" Literate Perl in TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn include @xh syntax/xh.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

syn include @js syntax/caterwaul.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

syn include @html syntax/html.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

runtime syntax/perl.vim

syn case match
syn match  pltPreprocessor /^\s*- .*$/ containedin=pltImpliedComment
syn region pltImpliedComment matchgroup=pltPreprocessor start=/\%^\|^\s*- end$/ end=/^\s*- perl.*$\|\%$/ keepend containedin=ALL
syn region pltXhRegion       matchgroup=pltPreprocessor start=/^\s*- xh.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@xh keepend
syn region pltJsRegion       matchgroup=pltPreprocessor start=/^\s*- js.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@js keepend
syn region pltHtmlRegion     matchgroup=pltPreprocessor start=/^\s*- html.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@html keepend

hi link pltImpliedComment Comment
hi link pltPreprocessor   PreProc

let b:current_syntax = "perltex"

__
internal::main();

__DATA__
